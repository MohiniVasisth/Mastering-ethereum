[[tokens_chapter]]
== Tokeny


((("tokens", id="ix_10tokens-asciidoc0", range="startofrange"))) Slovo „token“ pochází ze staroanglického slova „tācen“, což znamená znaménko nebo symbol. Obyčejně je používáno při odkazování na soukromě vydávané, mincím podobné věci se speciálním účelem, nízké vnitřní hodnoty. Příklady mohou být přepravní žetony, žetony do prádelen a žetony do arkádové hry. Poznámka překladate: Pro token se používá český překlad žeton, pouze pokud má hmotnou podobu. Nehmotné tokeny se používaly v informatice již dávno před vznikem ktyptoměn a ponechávaly se bez překladu.

V současné době „tokeny“ spravované na bločenkách předefinují slovo tak, že znamenají abstrakce založené na bločence, které mohou být ve vlastněné a které představují aktiva, měnu nebo přístupová práva.

Asociace mezi slovem „token“ a nevýznamnou hodnotou má hodně co do činění s omezeným použitím fyzických verzí tokenů (nazývaných žetony). Fyzické tokeny, které jsou často omezeny na konkrétní firmy, organizace nebo umístění, nejsou snadno vyměnitelné a obvykle mají pouze jednu funkci. U bločenkových tokenů jsou tato omezení zrušena - nebo přesněji zcela předefinovatelná. Mnoho bločenkových tokenů slouží globálně pro různé účely a lze je na obchodovat na světových likvidních trzích za jiné tokeny nebo měny. Omezení na vlastnictví a používání zmizelo, stejně tak očekávání „zanedbatelné hodnoty“ je také minulostí.

V této kapitole se podíváme na různá použití tokenů a na to, jak jsou vytvořeny. Diskutujeme také o vlastnostech tokenů, jako je zastupitelnost a přirozenost. Nakonec zkoumáme standardy a technologie, na nichž jsou založeny, a experimentujeme vytvořením vlastních tokenů.

[[tokens_use]]
=== Jak se používají tokeny

((("tokens","uses of", id="ix_10tokens-asciidoc1", range="startofrange")))Nejviditelnějším použitím tokenů jsou digitální soukromé měny. Toto je však pouze jedno možné použití. Tokeny lze naprogramovat tak, aby sloužily mnoha různým funkcím, které se často překrývají. Například token může současně zprostředkovat hlasovací právo, přístupové právo a vlastnictví zdroje. Jak ukazuje následující seznam, měna je pouze první „aplikace“:

Měna:: Token může sloužit jako forma měny s hodnotou určenou soukromým obchodem.

Zdroj:: Token může představovat zdroj získaný nebo vytvořený ve sdílené ekonomice nebo prostředcích sdílení zdrojů; například úložiště nebo CPU token představující prostředky, které lze sdílet v síti.

Aktivum:: Token může představovat vlastnictví vlastního nebo vnějšího, hmotného nebo nehmotného aktiva; například zlata, nemovitosti, auta, ropy, energie, předmětů z online her (MMOG), atd.

Přístup:: Token může představovat přístupová práva a udělit přístup k digitálnímu nebo fyzickému majetku, jako je diskusní fórum, exkluzivní web, hotelový pokoj nebo půjčovna aut.

Vlastní kapitál:: Token může představovat vlastní kapitál v digitální organizaci (např. DAO) nebo právnické osobě (např. v korporaci).

Hlasování:: Token může představovat hlasovací práva v digitálním nebo právním systému.

Sběratelství:: Token může představovat digitální sběratelský (collectible) předmět (např. CryptoPunks) nebo fyzický sběratelský předmět (např. obraz).

Identita:: Token může představovat digitální identitu (např. Avatar) nebo legální identitu (např. občanský průkaz).

Osvědčení:: Token může představovat certifikaci nebo potvrzení skutečnosti některou autoritou nebo decentralizovaným systémem reputace (např. záznam manželství, rodný list, vysokoškolský titul).

Obsluha:: Token lze použít k přístupu nebo platbě za službu.

Jeden token často zahrnuje několik těchto funkcí. Někdy je mezi nimi těžké rozeznat, protože fyzické ekvivalenty byly vždy neoddělitelně spjaty. Například ve fyzickém světě je řidičský průkaz (osvědčení) rovněž dokladem totožnosti (totožnost) a tyto dva nelze oddělit. V digitální sféře mohou být dříve smíšené funkce odděleny a vyvíjeny samostatně (např. anonymní osvědčení). (((range="endofrange", startref="ix_10tokens-asciidoc1")))

[[tokens_fungibility]]
=== Tokeny a zaměnitelnost

((("fungible tokens", seealso="ERC20 token standard")))((("tokens","fungibility")))https://en.wikipedia.org/wiki/Fungibility [Wikipedia] říká: “ V ekonomice je zastupitelnost vlastností zboží, jehož jednotlivé jednotky jsou v podstatě zaměnitelné. “

Tokeny jsou zastupitelné, když můžeme nahradit jakoukoli jednu jednotku tokenu jinou, aniž by došlo k rozdílu v jeho hodnotě nebo funkci.

Přísně vzato, pokud je možné sledovat historický původ tokenu, pak není úplně zastupitelný. Schopnost sledovat původ může vést k seznamu zakázaných (blacklist) nebo povolených (whitelist) adres, snížení nebo eliminaci zastupitelnosti.

((("non-fungible tokens (NFTs)")))Nezaměnitelné tokeny jsou tokeny, z nichž každý představuje jedinečnou hmotnou nebo nehmotnou položku, a proto nejsou zaměnitelné. Například token, který představuje vlastnictví _konkrétního_ obrazu od Van Gogha, není rovnocenný s jiným tokenem, který představuje obraz od Picassa, přestože mohou být součástí stejného systému „tokeny vlastnictví umění“. Podobně token představující specifický digitální sběratelský materiál, jako je konkrétní krypto koťátko (CryptoKitty), není zaměnitelný s jiným krypto koťátkem. Každý nezaměnitelný token je spojen s jedinečným identifikátorem, jako je například sériové číslo.

V další části této kapitoly si ukážeme příklady zaměnitelných i nezaměnitelných tokenů.

[NOTE]
====
Všimněte si, že „zaměnitelný“ se často používá jako „přímo směnitelný za peníze“ (například žeton kasina může být „proplacen“, zatímco žetony prádla obvykle nemohou). Toto není smysl, ve kterém zde používáme toto slovo.
====

[[counterparty_risk]]
=== Riziko protistrany

((("counterparty risk")))((("tokens","counterparty risk")))Riziko protistrany je riziko, že strana v transakci nesplní své závazky. Některé typy transakcí jsou vystaveny dodatečnému riziku protistrany, protože jsou zapojeny více než dvě strany. Pokud například držíte depozitní certifikát pro drahý kov a prodáváte jej někomu, jsou v této transakci alespoň tři strany: prodávající, kupující a depozitář drahého kovu. Ten, kdo drží fyzické aktivum, se nutně stává stranou při plnění transakce a zvyšují riziko protistrany u každé transakce týkající se tohoto aktiva. Obecně platí, že pokud se s aktivem obchoduje nepřímo prostřednictvím výměny symbolu vlastnictví, existuje další riziko protistrany ze strany depozitáře aktiva. Mají to aktivum? Rozpoznají (nebo povolí) převod vlastnictví na základě převodu tokenu (jako je certifikát, listina, titul nebo digitální token)? Ve světě digitálních tokenů představujících aktiva, stejně jako v nedigitálním světě, je důležité pochopit, kdo drží aktivum reprezentované tokenem a jaká pravidla platí pro dané podkladové aktivum.

[[tokens_intrinsicality]]
=== Tokeny a vnitřnost

((("tokens","intrinsicality")))Slovo „vnitřnost“ ("intrinsic) je odvozeno z latinského slova  „intra“, což znamená „zevnitř“.

Některé tokeny představují digitální položky, které jsou uvnitř bločenky. Tato digitální aktiva se řídí pravidly konsensu, stejně jako samotné tokeny. To má důležitý důsledek: tokeny, které představují vlastní aktiva, nepředstavují další riziko protistrany. Pokud držíte klíč pro krypto koťátko, neexistuje žádná jiná strana, která by vaše krypto koťátko držela za vás - vlastníte ji přímo. Platí pravidla konsenzu bločenky a vaše vlastnictví (tj. kontrola) soukromých klíčů je ekvivalentní vlastnictví aktiva bez jakéhokoli zprostředkovatele.

Naopak, mnoho žetonů se používá k reprezentaci _vnějších_ (extrinsic) věcí, jako jsou nemovitosti, akcie s hlasovacím právem společnosti, ochranné známky a zlaté cihly. Vlastnictví těchto položek, které nejsou „uvnitř“ bločenky, se řídí zákonem, zvykem a politikou, odděleně od pravidel konsensu, kterými se řídí token. Jinými slovy, vydavatelé tokenů a vlastníci mohou stále záviset na skutečných vnějších smlouvách. Výsledkem je, že tato vnější aktiva nesou další riziko protistrany, protože jsou držena depozitáři, evidována v externích registrech nebo kontrolována zákony a politikou mimo prostředí bločenky.

Jedním z nejdůležitějších důsledků tokenů založených na bločence je schopnost převádět vnější aktiva na vnitřní aktiva a tím odstranit riziko protistrany. Dobrým příkladem je přechod z vlastního kapitálu v korporaci (vnější) na kmenový nebo hlasovací token v _DAO_ nebo podobné (vnitřní) organizaci.

[[using_tokens]]
=== Používání tokenů: užitek nebo majetkový podíl

((("tokens","utility/equity types", id="ix_10tokens-asciidoc2", range="startofrange")))Téměř všechny projekty v Ethereu se dnes spouští s jakýmsi tokenem. Potřebují však všechny tyto projekty tokeny? Existují nějaké nevýhody používání tokenu, nebo uvidíme slogan „tokenizovat všechny věci“? Použití tokenů lze v zásadě chápat jako konečný nástroj pro správu nebo organizaci. V praxi integrace bločenkových platforem, včetně Etherea, do stávajících struktur společnosti, má omezenou použitelnost, dosud existuje mnoho omezení.

Začněme objasněním role tokenu v novém projektu. Většina projektů používá tokeny jedním ze dvou způsobů: buď jako „obslužné tokeny“ (utility) nebo jako „tokeny vlastního kapitálu“ (equity). Tyto dvě role jsou velmi často spojeny.

((("utility tokens","defined")))Užitkové tokeny jsou ty, u nichž je pro získání přístupu ke službě, aplikaci nebo zdroji nutné použít token. Příklady obslužných tokenů zahrnují tokeny, které představují prostředky, jako je sdílené úložiště nebo přístup ke službám, jako jsou sítě sociálních médií.

((("equity tokens","defined"))) Majetkové tokeny jsou ty, které představují podíly na ovládání nebo vlastnictví něčeho, jako je startup. Majetkové tokeny mohou být stejně omezené jako akcie bez hlasovacího práva pro distribuci dividend a zisků, nebo mohou být expanzivní jako akcie s hlasovacím právem v decentralizované autonomní organizaci, kde je řízení platformy prostřednictvím nějakého složitého systému správy založeného na hlasování držitelů tokenů.

[[its_not_duck]]
==== Je to kachna!

((("equity tokens","utility tokens as")))((("utility tokens","equity tokens disguised as")))Mnoho startupů čelí složitému problému: tokeny jsou skvělým mechanismem financování, ale nabízení cenných papírů (majetkový podíl) pro veřejnost je ve většině jurisdikcí regulovaná činnost. Zamaskováním tokenů vlastního kapitálu jako obslužných tokenů mnoho startupů doufá, že obejdou tato regulační omezení a získají peníze z veřejné nabídky a zároveň je prezentují jako předprodej „poukázek na přístup ke službám“ nebo, jak tomu říkáme, obslužných tokenů. Zda budou tyto pokusy maskované nabídky vlastního kapitálu schopny uspokojit regulátory, ještě uvidíme.

Jak říká lidové přísloví: „Pokud chodí jako kachna a kváká jako kachna, je to kachna.“ Regulátoři pravděpodobně nebudou těmito sémantickými drobnostmi rozptylováni; právě naopak, je pravděpodobné, že vidí takovou právní kličku jako pokus podvádět veřejnost.

[[who_needs_utility_tokens]]
====Obslužné Tokeny: Kdo je potřebuje?

((("utility tokens","issues to consider when using", id="ix_10tokens-asciidoc3", range="startofrange")))Skutečným problémem je, že obslužné tokeny představují pro startupy značná rizika a překážky v adopci. Možná se ve vzdálené budoucnosti stane „tokenizace všech věcí“ realita, ale v současné době je množina lidí, kteří mají znalosti a touhu používat token, podmnožinou již tak malého trhu kryptoměn.

Každá inovace představuje pro startup riziko a tržní filtr. Inovace vede po cestě nejméně vyšlapané a odchází z tradiční cesty. Je to skutečně osamělá procházka. Pokud se startup pokouší inovovat v nové oblasti technologie, jako je sdílení úložiště přes P2P sítě, je to dost osamělá cesta. Přidání obslužného tokenu do této inovace a vyžadování, aby uživatelé přijali tokeny za účelem využití služby, zvyšuje riziko a zvyšuje překážky přijetí. Je to krok z již osamělé stezky inovace P2P úložiště přímo do divočiny.

Každou inovaci považujte za filtr. Omezuje přijímání na podmnožinu trhu, která se může stát raným osvojitelem této inovace. Přidání druhého filtru dále omezuje adresovatelný trh. Žádáte své dřívější osvojitele, aby přijali nejen jednu, ale dvě zcela nové technologie: novou aplikaci / platformu / službu, kterou jste vytvořili, a tokenovou ekonomiku.

Pro startupy, každá inovace představuje rizika, která zvyšují pravděpodobnost selhání startupu. Pokud využijete svůj již riskantní nápad pro startup a přidáte obslužný token, přidáváte všechna rizika základní platformy (Ethereum), širší ekonomiky (burzy, likvidita), regulačního prostředí (regulátory akcií / komodit) a technologií (chytré kontrakty , standardy tokenů). To je pro startup velké riziko.

Zastánci „tokenize všech věcí“ budou pravděpodobně uvádět opačné argumenty, že přijetím tokenů také zdědí tržní nadšení, dřívější osvojitele, technologii, inovaci a likviditu celé tokenové ekonomiky. To je také pravda. Otázkou je, zda přínosy a nadšení převažují nad riziky a nejistotami.

Nicméně některé z nejinovativnějších podnikatelských nápadů se skutečně odehrávají v kryptoměně. Pokud regulační orgány nejsou dostatečně rychlé na to, aby přijaly zákony a podporovaly nové obchodní modely, budou se podnikatelé a související talenty snažit působit v jiných jurisdikcích, které jsou více kryptografické. To se již děje.

Nakonec jsme na začátku této kapitoly při zavádění tokenů hovořili o hovorovém významu „tokenu“ jako o „něčem bezvýznamném“. Základním důvodem pro zanedbatelnou hodnotu většiny tokenů je to, že je lze použít pouze ve velmi úzkém kontextu: jedna autobusová společnost, jedna prádelna, jedna podloubí, jeden hotel nebo jeden firemní obchod. Omezená likvidita, omezená použitelnost a vysoké náklady na konverzi snižují hodnotu tokenů, dokud nejsou pouze „token“. Když tedy na svou platformu přidáte obslužný token, ale tento token lze použít pouze na jedné platformě s malým trhem, znovu vytváříte podmínky, díky nimž jsou fyzické žetony bezcenné. To může být opravdu správný způsob, jak začlenit tokenizaci do vašeho projektu. Pokud však uživatel potřebuje použít vaši platformu, musí převést něco na váš obslužný token, použít jej a poté převést zbytek zpět na něco obecně užitečnějšího, vytvořili jste firemní měnu s nuceným oběhem. Náklady na přepínání digitálního tokenu jsou řádově nižší než u fyzického tokenu bez trhu, ale nejsou nulové. Obslužné tokeny, které fungují napříč celým odvětvím, budou velmi zajímavé a pravděpodobně docela cenné. Pokud však nastavíte startup tak, aby musel zavést celý průmyslový standard, abyste uspěli, možná jste již selhali.

[NOTE]
====
Jednou z výhod nasazení služeb na univerzálních platformách, jako je Ethereum, je schopnost propojit chytré kontrakty (a tedy i obslužné tokeny) napříč projekty, což zvyšuje potenciál likvidity a užitečnosti tokenů.
====

((("tokens","reasons to adopt")))Toto rozhodnutí učiňte ze správných důvodů. Zaveďte token, protože vaše aplikace nemůže fungovat bez tokenu_. Zaveďte jej, protože token odstraňuje zásadní překážku na trhu nebo řeší problém s přístupem. Nezavádějte obslužný token, protože je to jediný způsob, jak můžete rychle získat peníze a musíte předstírat, že se nejedná o veřejnou nabídku cenných papírů (((range="endofrange", startref="ix_10tokens-asciidoc3"))).(((range="endofrange", startref="ix_10tokens-asciidoc2")))

[[token_std]]
=== Ethereum tokeny

((("tokens","on Ethereum", id="ix_10tokens-asciidoc4", range="startofrange")))Bločenkové tokeny existovaly před Ethereem. ((("Bitcoin","as token")))V některých ohledech je první bločenková měna, Bitcoinem, sám o sobě token. Před platformou Ethereum bylo také vyvinuto mnoho tokenových platforem na Bitcoinu a dalších kryptoměnách. Zavedení prvního standardu tokenů na Ethereu však vedlo k explozi tokenů.

((("Buterin, Vitalik","on tokens")))Vitalik Buterin navrhl tokeny jako jednu z nejzjevnějších a nejužitečnějších aplikací zobecněného programovatelné bločenky, jako je Ethereum. Ve skutečnosti v prvním rocea Etherea bylo běžné, že Vitalik a další měli na sobě trička zdobená logem Etherea a na zadní straně kus chytrého kontraktu. Tato trička měla několik variant, ale nejběžnější ukazovala implementaci tokenu.

Než se pustíme do podrobností o vytváření Ethereum tokenů, je důležité mít přehled o tom, jak tokeny fungují na Ethereu. Tokeny se liší od etheru, protože o nich Ethereum protokol nic neví. Posílání etheru je vlastní činností platformy Ethereum, ale odesílání nebo dokonce vlastnění tokenů není. Etherový zůstatek Ethereum účtů je zpracován na úrovni protokolu, zatímco tokenový zůstatek Ethereum účtů je zpracován na úrovni chytrých kontraktů. Chcete-li vytvořit nový token na Ethereu, musíte vytvořit nový chytrý kontrakt. Po nasazení chytrý kontrakt zpracovává vše, včetně vlastnictví, převodů a přístupových práv. Svůj chytrý kontrakt můžete napsat, abyste mohli provést všechny potřebné akce jakýmkoli způsobem, ale pravděpodobně je nejmoudřejší sledovat existující standardy. Dále se podíváme na takovéto standardy. Na konci kapitoly diskutujeme o výhodách a nevýhodách následujících standardů.


[[ERC20_std]]
==== Standard tokenu ERC20

((("ERC20 token standard", id="ix_10tokens-asciidoc5", range="startofrange")))((("tokens","ERC20 standard", id="ix_10tokens-asciidoc6", range="startofrange")))První standard byl představen v listopadu 2015 Fabianem Vogelstellerem jako žádost o připomínku k Ethereu (ERC). Bylo mu automaticky přiděleno číslo 20 na GitHubu, čímž vznikl název „ERC20 token“. Převážná většina tokenů je v současné době založena na standardu ERC20. Žádost o připomínky ERC20 se nakonec stala návrhem na vylepšení 20 (EIP-20), ale většinou se na něj stále odkazuje původní název ERC20.

ERC20 je standard pro _zaměnitelné tokeny_, což znamená, že různé jednotky ERC20 tokenu jsou vzájemně zaměnitelné a nemají žádné jedinečné vlastnosti.

http://bit.ly/2CUf7WG[ERC20 standard] definuje společné rozhraní pro kontrakty implementující token, takže ke každému kompatibilnímu tokenu lze přistupovat a používat ho stejným způsobem. Rozhraní se skládá z řady funkcí, které musí být přítomny v každé implementaci standardu, jakož i z některých volitelných funkcí a atributů, které mohou vývojáři přidat.

[[ERC20_reqd_func]]
===== ERC20 požadované funkce a události

((("ERC20 token standard","required functions and events")))Kontrakt tokenu v souladu s ERC20 musí poskytovat alespoň následující funkce a události:

+totalSupply+::Vrátí celkové množství jednotek tohoto tokenu, které aktuálně existují. Tokeny ERC20 mohou mít pevný nebo variabilní počet jednotek.

+balanceOf+:: Pro danou adrese vrací tokenový zůstatek této adresy.

+transfer+:: Pro zadanou adresu a množství převede toto množství tokenů na tuto adresu ze zůstatku adresy, která provedla převod.

+transferFrom+:: Pro zadaného odesílatele, příjemce a množství převádí tokeny z jednoho účtu na druhý. Používá se v kombinaci s +approved+.

+approve+:: Pro zadanou adresu příjemce a množství opravňuje tuto adresu k provedení několika převodů z účtu, který vydal schválení, až do tohoto uvedeného množství.

+allowance+:: Pro zadanou adresu majitele a adresu disponenta vrátí zbývající částku, kterou má disponent schválenou k výběru od vlastníka.

+Transfer+:: Událost spuštěná po úspěšném převodu (volání +transfer+ nebo +transferFrom+) (i pro převody s nulovým množstvím).

+Approval+:: Událost zaznamenaná po úspěšném volání +approve+.

[[ERC20_optional_func]]
===== Volitelné funkce ERC20

((("ERC20 token standard","optional functions")))Kromě požadovaných funkcí uvedených v předchozí části jsou standardem definovány také následující volitelné funkce:

+name+:: Vrací lidsky čitelné jméno (např. „americké dolary“) tokenu.

+symbol+::  Vrací lidsky čitelný symbol (např. „USD“) tokenu.

+decimals+:: Vrací počet desetinných míst použitých k rozdělení množství tokenů. Pokud má například +decimals+ hodnotu +2+, pak je částka tokenu vydělena 100, aby se získalo jeho uživatelské pass:[<span class="keep-together">zobrazení</span>].

[[ERC20_interface]]
===== Rozhraní ERC20 definované v Solidity

((("ERC20 token standard","interface defined in Solidity")))Zde je uvedeno, jak specifikace ERC20 rozhraní vypadá v Solidity:

[[ERC20_interface_example]]
[source,solidity]
----
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns
      (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns
      (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
----

[[ERC20_data_struct]]
===== Struktura dat ERC20

((("data mapping")))((("ERC20 token standard","data structures"))) Pokud prozkoumáte jakoukoli implementaci ERC20, uvidíte, že obsahuje dvě datové struktury, jednu pro sledování zůstatků a druhou pro sledování povolení. V Solidity jsou implementovány pomocí _mapování dat_.

První mapování dat implementuje interní tabulku bilancí tokenů podle vlastníka. To umožňuje tokenovému kontraktu sledovat, kdo vlastní tokeny. Každý převod je odečten z jednoho zůstatku a přičten k jinému zůstatku:

[[balance_mapping]]
[source,solidity]
----
mapping(address => uint256) balances;
----

Druhou datovou strukturou je datové mapování povolení. Jak uvidíme v další části, s tokeny ERC20 může vlastník tokenu delegovat oprávnění na disponenta (spender), což mu umožní utratit určité povolené množství (allowance) ze zůstatku vlastníka. ERC20 kontrakt sleduje povolenky pomocí dvourozměrného mapování, přičemž primárním klíčem je adresa majitele tokenu, mapovaná na adresu disponenta a povolené množství:

[[allowance_mapping]]
[source,solidity]
----
mapping (address => mapping (address => uint256)) public allowed;
----


[[transfer_workflows]]
===== Pracovní postupy ERC20: "transfer" a "approve & transferFrom"

((("ERC20 token standard","transfer functions", id="ix_10tokens-asciidoc7", range="startofrange")))((("transfer function","ERC20 token standard", id="ix_10tokens-asciidoc8", range="startofrange")))Tokenový standard ERC20 má dvě převodové funkce. Možná se divíte, proč.

ERC20 umožňuje dva různé pracovní postupy. První je jednoduchá transakce, přímý pracovní postup pomocí funkce +transfer+. Tento pracovní postup je ten, který používají peněženky k odesílání tokenů na jiné peněženky. Převážná většina převodů tokenů se odehrává v rámci pracovního postupu +transfer+.

Provedení převodu v rámci kontraktu je velmi jednoduché. Pokud chce Alice poslat Bobovi 10 tokenů, její peněženka odešle transakci na adresu tokenového kontraktu, volá funkci pass:[<span class="keep-together"><code>transfer</code></span>] s parametry Bobova adresa a +10+. Tokenový kontrakt upraví zůstatek Alice (–10) a Bobův zůstatek (pass:[+10]) a vyšle událost +Transfer+.

((("approve & transferFrom workflow")))Druhým pracovním postupem jsou dvě transakce, nejprve volání +approval+ následované voláním +transferFrom+. Tento pracovní postup umožňuje vlastníkovi tokenu delegovat jeho kontrolu na jinou adresu. Nejčastěji se používá k delegování kontroly na kontrakt o distribuci tokenů, ale lze ho také použít burzami.

((("Initial Coin Offerings (ICOs)","tokens and")))Například pokud společnost prodává žetony pro ICO, může schválit (+approve+) adrese kontraktu veřejného prodeje distribuovat určité množství tokenů. Prodejní kontrakt pak může převést (+transferFrom+) zůstatek majitele tokenového kontraktu na každého kupujícího tokenu, jak je znázorněno v <<approve_transferFrom_workflow>>.

[NOTE]
====
((("Initial Coin Offerings (ICOs)","defined")))_Počáteční nabídka mincí_ (Initial Coin Offering; CO) je mechanismus skupinového financování používaný společnostmi a organizacemi k získávání peněz prodejem tokenů. Termín je odvozen od počáteční veřejné nabídky (Initial Public Offering; IPO), což je proces, kterým veřejná společnost nabízí akcie k prodeji investorům na burze. Na rozdíl od vysoce regulovaných trhů IPO jsou ICO otevřené, globální a chaotické. Příklady a vysvětlení ICO v této knize nejsou schvalováním tohoto typu získávání prostředků.
====

[[approve_transferFrom_workflow]]
.Schválení převodu a převod ERC20 tokenů
image::images/approve_transferFrom_workflow.png["Schválení převodu a převod ERC20 tokenů"]

Pro pracovní postup +approve+ & +transferFrom+ jsou nutné dvě transakce. Řekněme, že Alice chce povolit kontraktu +AliceICO+, aby prodal 50% všech tokenů AliceCoin kupujícím, jako je Bob a Charlie. Nejprve Alice nasadí kontrakt +AliceCoin+ ERC20 a vydá veškeré AliceCoin tokeny ve prospěch své vlastní adresy. Poté Alice nasadí +AliceICO+ kontrakt, která může prodávat tokeny za ether. Poté Alice zahájí pracovní postup +approve+ & +transferFrom+. Odešle transakci kontraktu +AliceCoin+, volá schválení +approval+ s adresou kontraktu +AliceICO+ a 50% z +totalSupply+ jako parametry. Tím se spustí událost schválení  +Approval+. Nyní může kontrakt +AliceICO+ prodávat AliceCoin.

Když kontrakt +AliceICO+ obdrží od Boba ether, musí na oplátku poslat Bobovi nějaké tokeny AliceCoin. V rámci kontraktu +AliceICO  je směnný kurz mezi AliceCoin tokeny a etherem. Směnný kurz, který Alice nastavila, když vytvořila kontrakt +AliceICO+, určuje, kolik tokenů Bob obdrží za dané množství etheru zaslané do kontraktu +AliceICO+. Když kontrakt +AliceICO+ volá funkci AliceCoin +transferFrom+, nastaví adresu Alice jako odesílatele a adresu Boba jako příjemce a pomocí směnného kurzu určí, kolik tokenů AliceCoin bude převedeno na Boba v poli hodnota +value+. Kontrakt +AliceCoin+ převádí zůstatek z adresy Alice na Bobovu adresu a spouští událost +Transfer+. Kontrakt +AliceICO+ může volat +transferFrom+ neomezeně krát, pokud nepřekročí Alicí stanovený limit množství tokenů. Kontrakt +AliceICO+ může sledovat, kolik tokenů AliceCoin může prodat voláním funkce +allowance+.(((range="endofrange", startref="ix_10tokens-asciidoc8")))(((range="endofrange", startref="ix_10tokens-asciidoc7")))

[[ERC20_implementation]]
===== Implementace ERC20

I když je možné implementovat token kompatibilní s ERC20 na přibližně 30 řádcích kódu Solidity, většina implementací je složitější. To je z důvodu zabezpečení proti možným chybám. Standard EIP-20 uvádí dvě implementace:

http://bit.ly/2EUYCMR[Consensys EIP20]:: Jednoduchá a snadno čitelná implementace tokenu kompatibilního s ERC20.

https://bit.ly/2xPYck6[OpenZeppelin StandardToken]:: Tato implementace je kompatibilní s ERC20 a s dalšími bezpečnostními opatřeními. Tvoří základ knihoven OpenZeppelin, které implementují složitější tokeny kompatibilní s ERC20 s limitem skupinového investování, aukcemi, dočasného zmražení (vesting schedules) a dalšími funkcemi. (((Range = &quot;endofrange&quot;, startref = &quot;ix_10tokens-asciidoc6&quot;))) (((range) = &quot;endofrange&quot;, startref = &quot;ix_10tokens-asciidoc5&quot;))))

[[METoken_example]]
==== Spuštění vlastního ERC20 tokenu 

(("ERC20 token standard","METoken creation/launch example", id="ix_10tokens-asciidoc9", range="startofrange")))((("METoken (Mastering Ethereum Token)","creation/launch example", id="ix_10tokens-asciidoc10", range="startofrange")))Let's create and launch our own token. For this example, we will use the Truffle framework. The example assumes you have already installed +truffle+ and configured it, and are familiar with its basic operation (for details, see <<truffle>>).

Nazveme náš token „Mastering Ethereum Token“ se symbolem „MET“.

[NOTE]
====
Tento příklad najdete https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken[v GitHub úložišti knihy].
====

Nejprve vytvořme a inicializujeme adresář projektu Truffle. Spusťte tyto čtyři příkazy a přijměte výchozí odpovědi na jakékoli otázky:

++++
<pre data-type="programlist">
$ <strong>mkdir METoken</strong>
$ <strong>cd METoken</strong>
METoken $ <strong>truffle init</strong>
METoken $ <strong>npm init</strong>
</pre>
++++

Nyní byste měli mít následující strukturu adresářů:

[[truffle_directory]]
----
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
`---- truffle.js
----

Upravte konfigurační soubor _truffle.js_ nebo _truffle-config.js_ a nastavte prostředí Truffle nebo jej zkopírujte z http://bit.ly/2DdP2mz[repozitáře].

Pokud použijete příklad _truffle-config.js_, nezapomeňte vytvořit soubor _.env_ ve složce _METoken_ obsahující vaše testovací soukromé klíče pro testování a nasazení ve veřejných testovacích Ethereum sítích, jako jsou Ropsten nebo Kovan. Váš soukromý klíč pro testovací síť můžete exportovat z MetaMasku.

Poté by měl váš adresář vypadat takto:

[[truffle_directory_metoken]]
----
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
+---- truffle.js
`---- .env *new file*
----

[WARNING]
====
Používejte pouze testovací klíče nebo testovací mnemotechnická slova, které nejsou používány k držení prostředků v hlavní Ethereum síti. _Nikdy_ nepoužívejte klíče, které drží skutečné peníze pro testování.
====

V našem příkladu importujeme knihovnu OpenZeppelin, která implementuje některé důležité bezpečnostní kontroly a lze ji snadno rozšířit:

++++
<pre data-type="programlist">
$ <strong>npm install openzeppelin-solidity@1.12.0</strong>

+ openzeppelin-solidity@1.12.0
added 1 package from 1 contributor and audited 2381 packages in 4.074s
</pre>
++++

Balíček +openzeppelin-solidity+ přidá asi 250 souborů do adresáře __node_modules__. Knihovna OpenZeppelin obsahuje mnohem více než ERC20 token, ale použijeme pouze malou část.

Dále pojďme napsat náš kontrakt tokenu. Vytvořte nový soubor _METoken.sol_ a zkopírujte kód příkladu z http://bit.ly/2qfIFH0[GitHubu].

Náš kontrakt uvedený v <<solidity_token_example>> je velmi jednoduchý, protože zdědí veškerou svou funkčnost z knihovny OpenZeppelin.

[[solidity_token_example]]
.METoken.sol: Solidity kontrakt implementující ERC20 token 
====
[source,solidity,linenums]
----
include::code/truffle/METoken/contracts/METoken.sol[]
----
====

Zde definujeme volitelné proměnné +name+, +symbol+, a +decimals+. Definujeme také proměnnou +_initial_supply+  nastavenou na 21 milionů tokenů; se dvěma desetinnými místy rozdělení, což dává celkem 2,1 miliardy jednotek. V funkci inicializace kontraktu (konstruktoru) jsme nastavili +totalSupply+ tak, aby se rovnalo +_initial_supply+ a alokovali všechny +_initial_supply+ do zůstatku na účtu (+msg.sender+), který vytváří kontrakt +METoken+.

Nyní zkompilujeme +METoken+ kód pomocí +truffle+:

++++
<pre data-type="programlist">
$ <strong>truffle compile</strong>
Compiling ./contracts/METoken.sol...
Compiling ./contracts/Migrations.sol...
Compiling openzeppelin-solidity/contracts/math/SafeMath.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol...
</pre>
++++

Jak vidíte, +truffle+ obsahuje potřebné závislosti z knihoven OpenZeppelin a tyto kontrakty také kompiluje.

Nastavíme migrační skript pro nasazení kontraktu +METoken+. Ve složce _METoken/migrations_ vytvořte nový soubor s názvem __2_deploy_contracts.js__. Zkopírujte obsah z příkladu http://bit.ly/2P0rHLl[v úložišti GitHub]:


[[METoken_migration]]
.2_deploy_contracts: Migrace pro nasazení METoken
[source,javascript,linenums]
----
include::code/truffle/METoken/migrations/2_deploy_contracts.js[]
----

Než to nasadíme do jedné z Ethereum testovacích sítí , spustíme místní bločenku, který vše otestuje. Spusťte bločenku +ganache+, buď z příkazové řádky pomocí +ganache-cli+, nebo z grafického uživatelského rozhraní.

Jakmile bude spuštěn +ganache+, můžeme nasadit náš +METoken+ token a zjistit, zda všechno funguje podle očekávání:

++++
<pre data-type="programlist">
$ <strong>truffle migrate --network ganache</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying METoken...
  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0
  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...
</pre>
++++

Na +ganache+ příkazové řádce bychom měli vidět, že naše implementace vytvořila čtyři nové transakce, jak je znázorněno v <<ganache_METoken>>.

[[ganache_METoken]]
.Nasazení METoken na ganache
image::images/ganache_metoken.png["Nasazení METoken na ganache"]

[[truffle_console]]
===== Interakce s METoken pomocí příkazové řádky Truffle

((("METoken (Mastering Ethereum Token)","interacting with via Truffle console", id="ix_10tokens-asciidoc11", range="startofrange")))((("Truffle","interacting with METoken via Truffle console", id="ix_10tokens-asciidoc12", range="startofrange")))Můžeme komunikovat s naším kontraktem  na +ganache+ bločence pomocí příkazové řádky Truffle. Toto je interaktivní prostředí JavaScriptu, které poskytuje přístup do prostředí Truffle a přes web3 do bločenky. V tomto případě připojíme konzolu Truffle k +ganache+ bločence:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt;
</pre>
++++

Výzva +truffle(ganache)>+ ukazuje, že jsme připojeni k +ganache+ bločence a jsme připraveni napsat naše příkazy. Příkazová řádka Truffle podporuje všechny příkazy +truffle+, takže bychom mohli +kompilovat+ a +migrovat+ z příkazové řádky. Tyto příkazy již byly spuštěny, takže pojďme přímo k samotnému kontraktu. Kontrakt +METoken+ existuje jako JavaScript objekt v prostředí Truffle. Na výzvu zadejte +**METoken**++ a vypíše se celá definice kontraktu:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken</strong>
{ [Function: TruffleContract]
  _static_methods:

[...]

currentProvider:
 HttpProvider {
   host: 'http://localhost:7545',
   timeout: 0,
   user: undefined,
   password: undefined,
   headers: undefined,
   send: [Function],
   sendAsync: [Function],
   _alreadyWrapped: true },
network_id: '5777' }
</pre>
++++

Objekt +METoken+ odhaluje také několik atributů, například adresu kontraktu (jak je nasazena příkazem +migrate+):

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
</pre>
++++

Pokud chceme komunikovat s nasazeným kontraktem, musíme použít asynchronní volání ve formě JavaScriptu „slibu“. Pomocí funkce +deployed+ získáme instanci kontraktu a poté zavoláme funkci +totalSupply+:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => instance.totalSupply())</strong>
BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
</pre>
++++

Dále použijeme účty vytvořené +ganache+ ke kontrole našeho METoken zůstatku a pošleme nějaký METoken na jinou adresu. Nejprve získáme adresy účtu:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>let accounts</strong>
undefined
truffle(ganache)&gt; <strong>web3.eth.getAccounts((err,res) => { accounts = res })</strong>
undefined
truffle(ganache)&gt; <strong>accounts[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
</pre>
++++

Seznam +accounts+ nyní obsahuje všechny účty vytvořené pomocí  ganache+ a  +account[0]+ je účet, který nasadil kontrakt +METoken+. Měl by mít zůstatek pass:[<span class="keep-together">METoken</span>], protože náš METoken konstruktor dává celý tokenovou zásobu na adresu, která ho vytvořila. Zkontrolujme:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =></strong>
                  <strong>{ instance.balanceOf(accounts[0]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2100000000 ] }</strong>
</pre>
++++

Nakonec převedeme 1 000,00 METoken z +account[0]+ na +account[1]+ voláním funkce kontraktu +transfer+:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.transfer(accounts[1], 100000) })</strong>
undefined
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.balanceOf(accounts[0]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2099900000 ] }</strong>
undefined
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.balanceOf(accounts[1]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>
</pre>
++++

[TIP]
====
METoken má 2 desetinná místa přesnosti, což znamená, že 1 METoken je v kontraktu 100 jednotek. Když převedeme 1 000 METoken, určíme hodnotu ve volání +100000+ při volání funkce +transfer+.
====

Jak vidíte, v v příkazové řádce má +account[0]+ nyní 20 999 000 MET a +account[1]+ má 1 000 MET.

Pokud přepnete do grafického uživatelského rozhraní+ganache+, viz <<ganache_METoken_transfer>> uvidíte transakci, která volala funkci +transfer+ . (((range="endofrange", startref="ix_10tokens-asciidoc12")))(((range="endofrange", startref="ix_10tokens-asciidoc11")))

[[ganache_METoken_transfer]]
.Přesun METoken na ganache
image::images/ganache_metoken_transfer.png["Přesun METoken na ganache"]

[[sending_erc20_tokens_contracts]]
===== Odesílání ERC20 tokenů na adresy kontraktu

((("Faucet.sol contract (test example)","METoken project", id="ix_10tokens-asciidoc13", range="startofrange")))((("METoken (Mastering Ethereum Token)","sending to contract addresses", id="ix_10tokens-asciidoc14", range="startofrange")))Zatím jsme nastavili ERC20 token a převedli některé tokeny z jednoho účtu na druhý. Všechny účty, které jsme použili pro tyto demonstrace, jsou externě vlastněné účty, což znamená, že jsou ovládány soukromým klíčem, nikoli kontraktem. Co se stane, pokud pošleme MET na adresu kontraktu? Pojďme to zjistit!

Nejprve nasaďme do našeho testovacího prostředí další kontrakt. V tomto příkladu použijeme náš první kontrarkt _Faucet.sol_. Přidáme jej do projektu METoken zkopírováním do adresáře _contracts_. Náš adresář by měl vypadat takto:

[[METoken_directory]]
----
METoken/
+---- contracts
|   +---- Faucet.sol
|   +---- METoken.sol
|   `---- Migrations.sol
----

Přidáme také migraci, abychom nasadili +Faucet+ odděleně od +METoken+:

[[faucet_migration]]
[source,solidity]
----
var Faucet = artifacts.require("Faucet");

module.exports = function(deployer) {
// Nasadit kontrakt Faucet jako náš jediný úkol
  deployer.deploy(Faucet);
};
----

Zkompilujme a migrujme kontrakty z konzole Truffle:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt; <strong>compile</strong>
Compiling ./contracts/Faucet.sol...
Writing artifacts to ./build/contracts

truffle(ganache)&gt; <strong>migrate</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9
  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba
  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f
Saving artifacts...
Running migration: 3_deploy_faucet.js
  Deploying Faucet...
  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3
  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524
Saving artifacts...
</pre>
++++

Skvělý. Nyní pošleme nějaký MET do kontraktu +Faucet+:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.transfer(Faucet.address, 100000) })</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(Faucet.address).then(console.log)})</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>
</pre>
++++

Dobře, převedli jsme 1 000 MET na kontrakt  +Faucet+. Jak nyní vybereme tyto tokeny?

Pamatujte, _Faucet.sol_ je velmi jednoduchý kontrakt. Má pouze jednu funkci, pass:[<span class="keep-together"><code>withdraw</code></span>], což je pro vybrání _etheru_. Nemá funkci pro vybrání MET nebo jiného  ERC20 tokenu. Použijeme-li +withdraw+, pokusí se odeslat ether, ale protože +Faucet+ zatím nemá zůstatek etheru, funkce selže.

Kontrakt +METoken+ ví, že +Faucet+ má zůstatek, ale jediný způsob, jak může tento zůstatek převést, je, pokud obdrží volání +transfer+ z adresy kontraktu. Nějak potřebujeme, aby kontrakt +Faucet+ volal funkci +transfer+ v pass:[<span class="keep-together"><code>METoken</code></span>].

Pokud vás zajímá, co dělat dál, tak neexistuje řešení tohoto problému. MET zaslaný na +Faucet+ je zaseknutý navždy. Převést ho může pouze kontrakt +Faucet+ a kontrakt +Faucet+ nemá kód pro volání funkce +transfer+ kontraktu ERC20 tokenu.

Možná jste tento problém předvídali. Pravděpodobně ale ne. Ve skutečnosti ani stovky Ethereum uživatelů, kteří omylem převedli různé tokeny na kontrakty, které neměly žádnou schopnost pracovat s ERC20. Podle některých odhadů se tokeny v hodnotě více než zhruba 2,5 milionu USD (v době psaní) „takto zasekly“ a jsou navždy ztraceny.

Jedním ze způsobů, jak uživatelé ERC20 tokenů mohou nechtěně ztratit své tokeny při přesunu, je pokus o přesun na burzu nebo jinou službu. Zkopírují Ethereum adresu z webové stránky burzy a myslí si, že na ni mohou jednoduše poslat tokeny. Mnoho burz však zveřejňuje přijímací adresy, které jsou ve skutečnosti kontrakty! Účelem těchto kontraktů je přijímat pouze éter, nikoliv ERC20 tokeny, nejčastěji přeposílají všechny prostředky, které jim byly zaslány do „studeného úložiště“ nebo jiné centralizované peněženky. Přes mnoho varování, která říká „neposílejte tokeny na tuto adresu,“ se tímto způsobem ztratí mnoho tokenů. (((range="endofrange", startref="ix_10tokens-asciidoc14")))(((range="endofrange", startref="ix_10tokens-asciidoc13")))

[[transfer_workflow_demo]]
===== Demonstrace pracovního postupu „Schválit a převést“

((("approve & transferFrom workflow", id="ix_10tokens-asciidoc15", range="startofrange")))((("Faucet.sol contract (test example)","METoken approve & transferFrom workflow demonstration", id="ix_10tokens-asciidoc16", range="startofrange")))((("METoken (Mastering Ethereum Token)","approve & transferFrom workflow demonstration", id="ix_10tokens-asciidoc17", range="startofrange")))Náš kontrakt +Faucet+ nemohl zpracovat ERC20 tokeny. Odeslání tokenů pomocí funkce +transfer+ vedlo ke ztrátě těchto tokenů. Pojďme nyní přepsat kontrakt a nechat ji zpracovat ERC20 tokeny. Konkrétně z toho uděláme kohoutek, který rozdá MET každému, kdo o to požádá.

V tomto příkladu vytvoříme kopii projektového adresáře _truffle_ (nazveme jej __METoken_METFaucet__), inicializujeme +truffle+ a +npm+, instalujeme závislosti OpenZeppelin a zkopírujeme kontrakt _METoken.sol_. Viz náš první příklad, v <<METoken_example>> pro podrobné pokyny.

Náš nový kontrakt kohoutku _METFaucet.sol_, bude vypadat jako <<METFaucet>>.

[[METFaucet]]
.METFaucet.sol: kohoutek pro METoken
====
[source,solidity,linenums]
----
include::code/truffle/METoken_METFaucet/contracts/METFaucet.sol[]
----
====

V základním příkladu +Faucet+ jsme provedli několik změn. Protože +METFaucet+ bude používat funkci +transferFrom+ v +METoken+,, bude potřebovat dvě další proměnné. Jedna bude udržovat adresu nasazeného +METoken+ kontraktu. Druhá bude držet adresu majitele MET, který schválí výběry z kohoutku. Kontrakt +METFaucet+ zavolá +METoken.transferFrom+ a dá jí pokyn, aby přesunul MET od vlastníka na adresu, odkud přišel požadavek na výběr z kohoutku.


Zde deklarujeme tyto dvě proměnné:

[source,solidity]
----
StandardToken public METoken;
address public METOwner;
----

Protože náš kohoutek musí být inicializován se správnými adresami pro +METoken+ a +METOwner+, musíme naprogramovat vlastní konstruktor:

[[custom_constructor]]
[source,solidity]
----
// METFaucet konstruktor - zadejte adresu kontraktu METoken a 
// adresu vlastníka, který bude schválený k transferFrom
function METFaucet(address _METoken, address _METOwner) public {

// Inicializujte METokenu z poskytnuté adresy
	METoken = StandardToken(_METoken);
	METOwner = _METOwner;
}
----

Další změna je ve funkci  +withdraw+. Namísto volání +transfer+, +METFaucet+ používá funkci +transferFrom+ v  +METoken+ a požádá +METoken+ o převod MET na uživatele kohoutku, která požádal o výběr:

[[transfer_met]]
[source,solidity]
----
// Použijte funkci transferFrom METoken
METoken.transferFrom(METOwner, msg.sender, withdraw_amount);
----

A konečně, protože náš kohoutek již neodesílá ether, měli bychom pravděpodobně zabránit tomu, aby někdo poslal ether na +METFaucet+, protože bychom nechtěli, aby se zasekl. Změníme nouzovou platby přijímající funkci tak, abychom odmítli příchozí ether, pomocí funkce +revert+ vrátíme všechny příchozí platby:

[[reject_incoming_eth]]
[source,solidity]
----
// ODMÍTNOUT jakýkoli příchozí ether
function () external payable { revert(); }
----

Nyní, když je náš kód _METFaucet.sol_ připraven, musíme upravit migrační skript pro nasazení kontraktu. Tento migrační skript bude o něco složitější, protože +METFaucet+ závisí na adrese +METoken+. K nasazení obou kontraktů postupně použijeme JavaScript příslib. Vytvořte __2_deploy_contracts.js__ takto:

[source,solidity]
----
var METoken = artifacts.require("METoken");
var METFaucet = artifacts.require("METFaucet");
var owner = web3.eth.accounts[0];

module.exports = function(deployer) {

// Nejdříve nasaďte kontrakt METoken
	deployer.deploy(METoken, {from: owner}).then(function() {
// Poté nasaďte METFaucet a předejte mu adresu METokenu a
// adresu vlastníka všech MET, který schválí METFaucet
		return deployer.deploy(METFaucet, METoken.address, owner);
  	});
}
----

Nyní můžeme vyzkoušet vše v příkazové řádce Truffle. Nejprve použijeme +migrate+ k nasazení kontraktu. Když je +METoken+ nasazený, přidělí všechny MET k účtu, který jej vytvořil, +web3.eth.accounts[0]+. Potom zavoláme funkci +approve+ pass:[<code><span class="keep-together">METoken</span></code>] pro schválení +METFaucet+ k zasílání až 1 000 MET jménem +web3.eth.accounts[0]+. Nakonec vyzkoušíme kohoutek a zavoláme +METFaucet.withdraw+ z +web3.eth.accounts[1]+ a pokusíme se vybrat 10 MET. Zde jsou příkazy příkazové řádky:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt; <strong>migrate</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x79352b43e18cc46b023a779e9a0d16b30f127bfa40266c02f9871d63c26542c7
  Migrations: 0xaa588d3737b611bafd7bd713445b314bd453a5c8
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0xc42a57f22cddf95f6f8c19d794c8af3b2491f568b38b96fef15b13b6e8bfff21
  METoken: 0xf204a4ef082f5c04bb89f7d5e6568b796096735a
  Replacing METFaucet...
  ... 0xd9615cae2fa4f1e8a377de87f86162832cf4d31098779e6e00df1ae7f1b7f864
  METFaucet: 0x75c35c980c0d37ef46df04d31a140b65503c0eed
Saving artifacts...
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.approve(METFaucet.address, 100000) })</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 0, c: [ 0 ] }</strong>
truffle(ganache)&gt; <strong>METFaucet.deployed().then(instance =>
                  { instance.withdraw(1000, {from:web3.eth.accounts[1]}) } )</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 3, c: [ 1000 ] }</strong>
</pre>
++++

Jak můžete vidět z výsledků, můžeme pomocí pracovního postupu +approve+ & +transferFrom+ autorizovat jeden kontrakt k převodu tokenů definovaných v jiném tokenu. Při správném použití mohou ERC20 tokeny používat EOA a další kontrakty.

Břemeno správného řízení ERC20 tokenů je však posunuto do uživatelského rozhraní. Pokud se uživatel nesprávně pokusí přenést ERC20  tokeny na adresu kontraktu a tento kontrakt není vybaven pro příjem ERC20 tokenů, tokeny budou ztraceny. (((range="endofrange", startref="ix_10tokens-asciidoc17")))(((range="endofrange", startref="ix_10tokens-asciidoc16")))(((range="endofrange", startref="ix_10tokens-asciidoc15"))).(((range="endofrange", startref="ix_10tokens-asciidoc10")))(((range="endofrange", startref="ix_10tokens-asciidoc9")))

[[ERC20_issues]]
==== Problémy s ERC20 tokeny

((("ERC20 token standard","issues with ERC20 tokens")))Přijetí standardu tokenů ERC20 bylo skutečně výbušné. Byly spuštěny tisíce tokenů, jak pro experimentování s novými schopnostmi, tak pro získávání finančních prostředků v různých aukcích „skupinového financování“ a ICO. Existují však potenciální úskalí, jak jsme viděli v otázce převodu tokenů na smluvní adresy.

Jedním z méně zřejmých problémů s ERC20 tokeny je to, že odhalují jemné rozdíly mezi tokeny a samotným etherem. Pokud je ether převeden transakcí, ta má jako cíl adresu příjemce. Převod tokenů probíhá v rámci _špecifického stavu  tokenového kontraku_ a má tokenový kontrakt jako svůj cíl, nikoli adresu příjemce. Tokenový kontrakt sleduje zůstatky a vydává události. Při převodu tokenu není příjemci tokenu ve skutečnosti odeslána žádná transakce. Místo toho je adresa příjemce přidána do mapování v rámci samotného tokenového kontraktu. Transakce odesílající ether na adresu mění stav adresy. Transakce převádějící token na adresu mění pouze stav tokenového kontraktu, nikoli stav adresy příjemce. Dokonce ani peněženka, která podporuje ERC20 tokeny, si neuvědomuje zůstatek tokenů, pokud uživatel výslovně nepřidá konkrétní „tokenový“ kontrakt. Některé peněženky sledují nejpopulárnější tokenové kontrakty k detekci zůstatků držených adresami, které kontrolují, ale to je omezeno na malý zlomek existujícího ERC20 pass:[<span class="keep-together">kontraktů</span>].

Ve skutečnosti je nepravděpodobné, že by uživatel _chtěl_ sledoval všechny zůstatky ve všech možných ERC20 tokenových kontraktech. Mnoho ERC20 tokenů je spíš jako e-mailový spam než použitelné tokeny. Automaticky vytvářejí zůstatky pro účty, které mají etherovou aktivitu, aby přilákaly uživatele. Pokud máte Ethereum adresu s dlouhou historií činnosti, zejména pokud byla vytvořena v předprodeji, najdete ji plnou „nezdravých“ tokenů, které se objevily z ničeho. Adresa samozřejmě není opravdu plná tokenů; jsou to tokenové kontrakty, které mají v sobě vaši adresu. Tyto zůstatky uvidíte pouze v případě, že tyto tokenové kontrakty sleduje průzkumník bloků nebo peněženka, kterou používáte k zobrazení vaší adresy.

Tokeny se nechovají stejně jako ether. Ether je odesílán funkcí +send+ a přijímán jakoukoli platby přijímající funkcí v kontraktu nebo na jakékoli externě vlastněné adrese. Tokeny se odesílají pomocí funkcí +transfer+ nebo +approve+ & +transferFrom+, které existují pouze v ERC20 kontraktu, a nespouštějí (alespoň v ERC20) žádné platby přijímající funkce v kontraktu příjemce. Tokeny mají fungovat jako kryptoměna, jako je ether, ale přicházejí s určitými rozdíly, které tuto iluzi narušují.

((("gas","tokens and")))((("tokens","gas and")))Zvažte další problém. Chcete-li poslat ether nebo použít jakýkoliv Ethereum kontrakt, musíte etherem zaplatit za plyn. Chcete-li poslat tokeny, _potřebujete také ether_. Nemůžete zaplatit za transakční plyn tokenem a tokenový kontrakt nemůže za vás zaplatit. To se může někdy ve vzdálené budoucnosti změnit, ale mezitím to může způsobit poněkud podivné uživatelské zkušenosti. Řekněme například, že používáte burzu nebo ShapeShift k převodu nějakých bitcoinů na token. „Dostanete“ token do peněženky, která sleduje tokenový kontrakt a zobrazuje váš zůstatek. Vypadá to stejně jako všechny ostatní kryptoměny, které máte v peněžence. Zkuste však poslat token a vaše peněženka vás informuje, že k tomu potřebujete ether. Můžete být zmatení - přece jen nepotřebujete ether, abyste dostali token. Možná nemáte ether. Možná jste ani nevěděli, že token je ERC20 token na Ethereu; Možná jste si mysleli, že to byla kryptoměna s vlastní bločenkou. Iluze se právě rozplynula.

Některé z těchto problémů jsou specifické pro ERC20 tokeny. Jiné jsou obecnější problémy, které se týkají abstrakce a hranic rozhraní v rámci Etherea. Některé mohou být vyřešeny změnou tokenového rozhraní, zatímco jiné mohou potřebovat změny základních struktur v rámci Etherea (jako je rozlišení mezi EOA a kontrakty a mezi transakcemi a zprávami). Některé nemusí být „řešitelné“ přesně a mohou vyžadovat návrh uživatelského rozhraní, aby skryly nuance a zajistily konzistentnost uživatelského prostředí bez ohledu na základní rozdíly.

V dalších částech se podíváme na různé návrhy, které se snaží některé z těchto problémů řešit.

[[ERC223_std]]
==== ERC223: Navrhovaný standard rozhraní tokenového kontraktu

((("ERC223 token standard proposal")))((("tokens","ERC223 standard proposal"))) Návrh ERC223 se pokouší vyřešit problém neúmyslného převodu tokenů na kontrakt (který může nebo nemusí podporovat tokeny) zjišťováním, zda je cílová adresa kontraktem nebo ne. ERC223 vyžaduje, aby kontrakty určené k přijetí tokenů implementovaly funkci nazvanou +tokenFallback+. Pokud je cílem převodu kontrakt a ten nemá podporu pro tokeny (tj. Neimplementuje +tokenFallback+), převod se nezdaří.

[[is_contract]]
K detekci, zda je cílová adresa kontraktem, používá referenční implementace ERC223 malý segment vloženého bajtkódu poměrně kreativním způsobem:

[source,solidity]
----
function isContract(address _addr) private view returns (bool is_contract) {
  uint length;
    assembly {
// načte velikost kódu na cílové adrese; to vyžaduje asembler
       length := extcodesize(_addr)
    }
    return (length>0);
}
----

[[ERC223_interface]]
Specifikace rozhraní ERC223 kontraktu je:

[source,solidity]
----
interface ERC223Token {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function decimals() public view returns (uint8 _decimals);
  function totalSupply() public view returns (uint256 _supply);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback)
      public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value,
                 bytes indexed data);
}
----

ERC223 není široce implementován a je debatována v https://github.com/ethereum/EIPs/issues/223[ERC diskuzním] vlákně o zpětné kompatibilitě a kompromisem mezi implementačními změnami v rozhraní kontraktu versus uživatelské rozhraní. Debata pokračuje.

==== ERC777: Navržený standard rozhraní smluvních tokenů

((("ERC777 token standard proposal", id="ix_10tokens-asciidoc18", range="startofrange")))((("tokens","ERC777 standard proposal", id="ix_10tokens-asciidoc19", range="startofrange")))Další návrh na vylepšení standardu tokenového kontraktu je https://eips.ethereum.org/EIPS/eip-777[ERC777]. Tento návrh má několik cílů, včetně:

* Nabídnout rozhraní kompatibilní s ERC20
* Převod tokenů pomocí funkce +send+, podobně jako převody etheru
*Kompatibilita s ERC820 pro registraci tokenového kontraktu
* Povolit, aby kontrakty a adresy kontrolovaly, které tokeny odesílají pomocí funkce „tokensToSend“, která se volá před odesláním
* Umožnit, aby kontrakty a adresy byly upozorňovány na příjem tokenů voláním funkce `tokensReceived` v příjemci, a snížením pravděpodobnosti, že budou tokeny uzamčeny v kontraktech tím, že požaduje, aby kontrakty poskytovaly funkci pass:[<span class="keep-together"><code>tokensReceived</code></span>]
* Povolit existujícím kontraktům používat zástupné kontrakty pro funkce +tokensToSend+ a +tokensReceived+ 
* Pracovat stejným způsobem, ať už se jedná o zaslání kontraktu nebo EOA
* Poskytovat konkrétní události pro ražbu a pálení tokenů
* Umožnit operátorům (důvěryhodným třetím stranám, které mají být ověřené kontrakty) pohybovat tokeny jménem držitele tokenů
* Poskytovat metadata o transakcích přenosu tokenů v polích +userData+ a +operatorData+

Probíhající diskusi o ERC777 lze nalézt na https://github.com/ethereum/EIPs/issues/777[GitHubu].

[[ERC777_interface]]
Specifikace rozhraní kontraktu ERC777 je:

[source,solidity]
----
interface ERC777Token {
    function name() public constant returns (string);
    function symbol() public constant returns (string);
    function totalSupply() public constant returns (uint256);
    function granularity() public constant returns (uint256);
    function balanceOf(address owner) public constant returns (uint256);

    function send(address to, uint256 amount, bytes userData) public;

    function authorizeOperator(address operator) public;
    function revokeOperator(address operator) public;
    function isOperatorFor(address operator, address tokenHolder)
        public constant returns (bool);
    function operatorSend(address from, address to, uint256 amount,
                          bytes userData,bytes operatorData) public;

    event Sent(address indexed operator, address indexed from,
               address indexed to, uint256 amount, bytes userData, 
               bytes operatorData);
    event Minted(address indexed operator, address indexed to,
                 uint256 amount, bytes operatorData);
    event Burned(address indexed operator, address indexed from,
                 uint256 amount, bytes userData, bytes operatorData);
    event AuthorizedOperator(address indexed operator,
                             address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
}
----

[[ERC777_hooks]]
===== ERC777 háčky

[[ERC777TokensSender_interface]]
Specifikace háčku pro odesílatele tokenů ERC777 je:

[source,solidity]
----
interface ERC777TokensSender {
    function tokensToSend(address operator, address from, address to,
                          uint value, bytes userData, bytes operatorData) public;
}
----

Implementace tohoto rozhraní je vyžadována pro jakoukoli adresu, která má být informována, zpracována nebo zabraňuje odečtu tokenů. Adresa, pro kterou kontrakt provádí toto rozhraní, musí být zaregistrována prostřednictvím ERC820, ať už kontrakt implementuje rozhraní pro sebe nebo pro jinou adresu.

[[ERC777TokensRecipient_interface]]
Specifikace háčku příjemce tokenu ERC777 je:

[source,solidity]
----
interface ERC777TokensRecipient {
  function tokensReceived(
     address operator, address from, address to,
    uint amount, bytes userData, bytes operatorData
  ) public;
}
----

Implementace tohoto rozhraní je vyžadována pro každou adresu, která chce být informována, zpracovávat nebo odmítat příjem tokenů. Stejná logika a požadavky se vztahují na příjemce tokenů jako na rozhraní odesílatele tokenů, s dodatečným omezením, že kontrakty příjemce musí implementovat toto rozhraní, aby se zabránilo zablokování tokenů. Pokud kontrakt příjemce nezaregistruje adresu implementující toto rozhraní, přenos tokenů selže.

Důležitým aspektem je, že na jednu adresu lze zaregistrovat pouze jednoho odesílatele tokenu a jednoho příjemce tokenu. Tudíž pro každý převod ERC777 tokenů jsou volány stejné háčky funkcí před odepsáním nebo připsáním každého přesunu ERC777  tokenů. Specifický token může být v těchto funkcích identifikován pomocí odesílatele zprávy, což je konkrétní adresa tokenového kontraktu, pro zpracování konkrétního případu použití.

Na druhou stranu, mohou být stejné háčky pro odesílání tokenů a příjemce tokenů zaregistrovány pro více adres a háčky mohou rozlišit, kdo jsou odesílatelem a zamýšleným příjemcem, pomocí parametrů `from` a` to`.

K návrhu je připojena http://bit.ly/2qkAKba[referenční implementace] ERC777. ERC777 závisí na paralelním návrhu registračního kontraktu, uvedeném v ERC820. Část debaty o ERC777 se týká složitosti přijímání dvou velkých změn najednou: nový standard tokenů a standard registrace. Diskuze pokračuje.(((range="endofrange", startref="ix_10tokens-asciidoc19")))(((range="endofrange", startref="ix_10tokens-asciidoc18")))

[[erc721]]
==== ERC721: Standard nezaměnitelného tokenu (vlastnická listina)

((("deed","and ERC721 non-fungible token standard", id="ix_10tokens-asciidoc20", range="startofrange")))((("ERC721 non-fungible token standard", id="ix_10tokens-asciidoc21", range="startofrange")))((("non-fungible tokens (NFTs)","ERC721 non-fungible token standard", id="ix_10tokens-asciidoc22", range="startofrange")))((("tokens","ERC721 non-fungible token standard", id="ix_10tokens-asciidoc23", range="startofrange")))Všechny standardy tokenů, na které jsme se dosud dívali, jsou pro _zaměnitelné_ tokeny, což znamená, že jednotky tokenů je navzájem zaměnitelné. Standard tokenů ERC20 sleduje pouze konečný zůstatek každého účtu a (explicitně) nesleduje původ žádného tokenu.

((("deed","defined")))The http://bit.ly/2Ogs7Im[Návrh ERC721] je standard pro _nezaměnitelné_ tokeny, také známé jako _vlastnické listiny_.

Z Oxfordského slovníku:

____
_vlastnická listina_: Právní dokument, který je podepsán a doručen, zejména dokument týkající se vlastnictví nebo zákonných práv.
____

Použití slova „vlastnická listina“  má zachycovat „vlastnictví majetku“, přestože v žádné jurisdikci nejsou dosud uznány jako „právní dokumenty“. Je pravděpodobné, že v budoucnu bude právní vlastnictví založené na digitálních podpisech na bločenkové platformě legálně uznáno.

Nezaměnitelné tokeny sledují vlastnictví jedinečné věci. Vlastněná může být digitální věc, například předmět ve hře nebo digitální sběratelská věc; nebo věcí může být fyzická věc, jejíž vlastnictví je sledováno tokenem, jako je dům, auto nebo umělecké dílo. Vlastnické listiny mohou také představovat věci se zápornou hodnotou, jako jsou půjčky (dluhy), zástavní práva, věcná břemena atd. Standard ERC721 neomezuje ani neočekává povahu věci, jejíž vlastnictví je sledováno vlastnickou listinou, a vyžaduje pouze to, aby byla jednoznačně identifikováno, což je v případě tohoto standardu dosaženo 256-bitovým pass: [<span class="keep-together">identifikátorem</span>].

Podrobnosti o standardu a diskuzi jsou sledovány na dvou různých GitHub pass:[<span class="keep-together">místech</span>]:

* https://github.com/ethereum/EIPs/issues/721[Počáteční návrh]

* https://github.com/ethereum/EIPs/pull/841[Pokračující diskuze]

[[map_deed_owner]]
Abychom pochopili základní rozdíl mezi ERC20 a ERC721, stačí se podívat na strukturu interních dat použitých v ERC721:

[source,solidity]
----
// Mapování ID vlastnické listiny na majitele
mapping (uint256 => address) private deedOwner;
----

Zatímco ERC20 sleduje zůstatky, které patří každému majiteli, přičemž vlastníkem je primární klíč mapování, ERC721 sleduje každé ID vlastnické listiny a kdo je jeho vlastníkem, přičemž ID vlastnické listiny je primárním klíčem mapování. Z tohoto základního rozdílu plynou všechny vlastnosti nezaměnitelného tokenu.

[[ERC721_interface]]
Specifikace rozhraní ERC721  kontraktu je:

[source,solidity]
----
interface ERC721 /* is ERC165 */ {
    event Transfer(address indexed _from, address indexed _to, uint256 _deedId);
    event Approval(address indexed _owner, address indexed _approved,
                   uint256 _deedId);
    event ApprovalForAll(address indexed _owner, address indexed _operator,
                         bool _approved);

    function balanceOf(address _owner) external view returns (uint256 _balance);
    function ownerOf(uint256 _deedId) external view returns (address _owner);
    function transfer(address _to, uint256 _deedId) external payable;
    function transferFrom(address _from, address _to, uint256 _deedId)
        external payable;
    function approve(address _approved, uint256 _deedId) external payable;
    function setApprovalForAll(address _operateor, boolean _approved) payable;
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
----

ERC721 také podporuje dvě _volitelná_ rozhraní, jedno pro metadata a druhé pro výčet vlastnických listin a majitelů.

[[ERC721_metadata]]
Volitelné rozhraní ERC721 pro metadata je:

[source,solidity]
----
interface ERC721Metadata /* is ERC721 */ {
    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function deedUri(uint256 _deedId) external view returns (string _deedUri);
}
----

[[ERC721_enum]]
Volitelné rozhraní ERC721 pro výčet je (((range="endofrange", startref="ix_10tokens-asciidoc23")))(((range="endofrange", startref="ix_10tokens-asciidoc22")))(((range="endofrange", startref="ix_10tokens-asciidoc21")))(((range="endofrange", startref="ix_10tokens-asciidoc20"))):(((range="endofrange", startref="ix_10tokens-asciidoc4")))

[source,solidity]
----
interface ERC721Enumerable /* is ERC721 */ {
    function totalSupply() external view returns (uint256 _count);
    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);
    function countOfOwners() external view returns (uint256 _count);
    function ownerByIndex(uint256 _index) external view returns (address _owner);
    function deedOfOwnerByIndex(address _owner, uint256 _index) external view
        returns (uint256 _deedId);
}
----

[[token_std_review]]
=== Používání tokenového standardu

((("token standards (generally)", seealso="specific standards, e.g.: ERC20 token standard", id="ix_10tokens-asciidoc24", range="startofrange")))((("tokens","using token standards", id="ix_10tokens-asciidoc25", range="startofrange"))) V předchozí části jsme přezkoumali několik navrhovaných standardů a několik široce nasazených standardů pro tokenové kontrakty. Co přesně tyto standardy dělají? Měli byste používat tyto standardy? Jak byste je měli používat? Měli byste přidat funkce nad rámec těchto standardů? Jaké standardy byste měli použít? Některé z těchto otázek dále prozkoumáme.

[[token_std_purpose]]
==== Jaké jsou tokenové standardy? Jaký je jejich účel?

((("token standards (generally)","defined")))Tokenové standardy jsou _minimální_ specifikací pro implementaci. To znamená, že pro splnění požadavků, řekněme, ERC20, musíte minimálně implementovat funkce a chování stanovené standardem ERC20. Můžete také volně  _přidat_ funkcionalitu implementací funkcí, které nejsou součástí standardu.

((("token standards (generally)","purpose of")))Primárním účelem těchto standardů je podpora _schopnosti spolupráce_ mezi kontrakty. Všechny peněženky, výměny, uživatelská rozhraní a další komponenty infrastruktury se tedy mohou _propojit_ (interface) předvídatelným způsobem s jakýmkoliv kontraktem, který následuje specifikaci. Jinými slovy, pokud nasadíte kontrakt, který odpovídá standardu ERC20, mohou všichni existující uživatelé peněženky hladce začít obchodovat s vaším tokenem bez jakéhokoli upgradu nebo úsilí z vaší strany.

Standardy jsou zamýšleny jako _ popisné_, nikoli _doslovné_. Jak se rozhodnete tyto funkce implementovat, záleží na vás - vnitřní fungování kontraktu není pro normu relevantní. Mají určité funkční požadavky, které řídí chování za určitých okolností, ale nepředepisují implementaci. Příkladem je chování funkce +transfer+, pokud je hodnota nastavena na nulu.

[[should_use_std]]
==== Měli byste používat tyto standardy?

((("token standards (generally)","reasons to use")))Vzhledem ke všem těmto standardům čelí každý vývojář dilematu: používat stávající standardy nebo inovovat nad rámec omezení, která stanoví?

Toto dilema není snadné vyřešit. Standardy nutně omezují vaši schopnost inovovat vytvořením úzké „koleje“, kterou musíte dodržovat. Na druhou stranu základní standardy vyplynuly ze zkušeností se stovkami aplikací a často dobře zapadají do převážné většiny případů použití.

Součástí této úvahy je ještě větší problém: hodnota schopnosti spolupracovat a široké přijetí. Pokud se rozhodnete použít existující standard, získáte hodnotu všech systémů navržených pro práci s tímto standardem. Pokud se rozhodnete odchýlit se od standardu, musíte zvážit náklady na vybudování veškeré podpůrné infrastruktury na vlastní pěst nebo přesvědčit ostatní, aby podpořili vaši implementaci jako nový standard. Tendence k vytvoření vlastní cesty a ignorování existujících standardů je známá jako syndrom „nevymýšlel jsem já“ a je protikladnou ke  kultuře otevřeného zdrojového kódu. Na druhé straně pokrok a inovace závisí na občasném odklonu od tradice. Je to složitá volba, proto ji pečlivě zvažte!

[NOTE]
====
Na Wikipedii, https://en.wikipedia.org/wiki/Not_invented_here[nevymyslel jsem já“] je postoj přijatý sociálními, podnikovými nebo institucionálními kulturami, který zabraňuje používání nebo nákupu již existujících produktů, výzkumu, standardů nebo znalostí. kvůli jejich vnějšímu původu a nákladům, jako jsou licenční poplatky.
====


[[security_maturity]]
==== Bezpečnost zralostí

((("security (smart contracts)","token standard implementation choices")))((("token standards (generally)","implementation choices")))Kromě volby standardu existuje paralelní výběr _implementace_. Pokud se rozhodnete použít normu, jako je ERC20, musíte se poté rozhodnout, jak implementovat kompatibilní návrh. Existuje celá řada existujících „referenčních“ implementací, které jsou v ekosystému Etherea široce využívány, nebo byste mohli napsat svojí vlastní od nuly. Tato volba opět představuje dilema, které může mít vážné bezpečnostní důsledky.

Stávající implementace jsou „testovány bitvou“. I když není možné prokázat, že jsou bezpečné, mnoho z nich podporuje tokeny v hodnotě milionů dolarů. Byli napadeni opakovaně a energicky. Dosud nebyly objeveny žádné významné chyby. Vlastní psaní není snadné - existuje mnoho jemných způsobů, jak může být kontrakt ohrožen. Je mnohem bezpečnější používat osvědčenou a široce používanou implementaci. V našich příkladech jsme použili implementaci OpenZeppelin standardu ERC20, protože tato implementace je od základu zaměřena na bezpečnost.

Pokud používáte existující implementaci, můžete ji také rozšířit. S tímto impulsem však buďte opět opatrní. Složitost je nepřítelem bezpečnosti. ((("attack surface")))Každý jednotlivý řádek kódu, který přidáte, rozšíří _plochu pro útok_  na váš kontrakt a může v budoucnu představovat zranitelnost. Možná si nevšimnete problému, dokud do kontraktu nevložíte vysokou hodnotu a někdo kontrakt nerozbije.

[TIP]
====
Standardy a možnosti implementace jsou důležitými součástmi celkového bezpečného návrhu chytrého kontraktu ale nejsou to jediné úvahy. Viz <<smart_contract_security>> (((range="endofrange", startref="ix_10tokens-asciidoc25")))(((range="endofrange", startref="ix_10tokens-asciidoc24")))
====


[[extend_token_interface]]
=== Rozšíření rozhraní tokenového standardu

((("token standards (generally)","extensions to")))Standardy tokenů popsané v této kapitole poskytují velmi minimální rozhraní s omezenou funkčností. Mnoho projektů vytvořilo rozšířené implementace na podporu funkcí, které potřebují pro své aplikace. Mezi tyto funkce patří:

Kontrola vlastníka:: Schopnost poskytovat konkrétní adrese nebo množině adres (tj. schémata více podpisů), speciální schopnosti, jako je tvoření seznamu zakázaných a povolených adres, ražení nových tokenů, obnova ztracených tokenů, atd.

Pálení:: Schopnost úmyslně zničit (&#x201c;burn&#x201d;)  tokeny jejich převodem na adresu, ze které nejde odeslat transakci, nebo vymazáním zůstatku a snížením celkového množství tokenů.

Ražba: Schopnost přidat k celkovému množství tokenů předvídatelnou rychlostí nebo „rozhodnutím“ (fiat) tvůrce nové tokeny.

Skupinové financování:: Schopnost nabízet tokeny k prodeji, například prostřednictvím aukce, tržního prodeje, reverzní aukce atd.

Zastropování: Schopnost nastavit předdefinované a neměnné limity na celkové množství tokenů (opak funkce „ražba“).

Zadní vrátka pro obnovu:: Funkce pro zpětné získání finančních prostředků, zpětné převody nebo rozebrání tokenu, kterou lze aktivovat na určené adrese nebo množině adres.

Seznam povolených adres:: Schopnost omezit akce (například přenos tokenů) na konkrétní adresy. Nejčastěji se používá k poskytování tokenů „akreditovaným investorům“ po prověření podle pravidel různých jurisdikcí. Obvykle existuje mechanismus pro aktualizaci seznamu povolených adres.

Seznam zakázaných adres: Schopnost omezit přenos tokenů zakázáním určitých adres. Obvykle existuje funkce pro aktualizaci černé listiny.

Pro mnoho z těchto funkcí existují referenční implementace, například v knihovně OpenZeppelin. Některé z nich jsou specifické pro konkrétní případ a jsou implementovány pouze v několika tokenech. Nyní neexistují široce přijímané standardy pro rozhraní těchto funkcí.

Jak již bylo uvedeno, rozhodnutí rozšířit tokenový standard o další funkce představuje kompromis mezi inovacemi / riziky a schopností spolupráce / zabezpečením.

[[tokens_ico]]
=== Tokeny a ICO

((("Initial Coin Offerings (ICOs)","tokens and")))((("tokens","ICOs and")))Tokeny prošly v ekosystému Etherea výbušným vývojem. Je pravděpodobné, že se stanou velmi důležitou součástí všech  platforem chytrých kontraktů, jako je Ethereum.

Důležitost a budoucí dopad těchto standardů by se však neměl zaměňovat s podporou současných tokenových nabídek. Stejně jako v jakékoli rané fázi technologie, první vlna produktů a společností téměř jistě selže, a některé selhají významně. Mnoho tokenů, které jsou dnes v Ethereu nabízeny, jsou špatně maskované podvody, pyramidová schémata a pasti na peníze.

Trik spočívá v oddělení dlouhodobé vize a dopadu této technologie, která bude pravděpodobně obrovská, od krátkodobé bubliny ICO tokenů, které jsou plné podvodů. Standardy tokenů a platforma přežijí současnou mánii tokenů a pak pravděpodobně změní svět.

=== Závěry

Tokeny jsou v Ethereu velmi silným konceptem a mohou tvořit základ mnoha důležitých decentralizovaných aplikací. V této kapitole jsme se podívali na různé typy tokenů a standardů tokenů a vytvořili jste první token a související aplikaci. Vrátíme se tokenům znovu v <<decentralized_applications_chap>>, kde použijeme nezaměnitelné tokeny jako základ DApp aukce.  (((range="endofrange", startref="ix_10tokens-asciidoc0")))