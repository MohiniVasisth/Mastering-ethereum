[[intro_chapter]]
== Conceitos Básicos sobre Ethereum

((("Ethereum (generally)","basics", id="ix_02intro-asciidoc0", range="startofrange"))) Neste capítulo, começaremos a explorar o Ethereum, aprendendo a usar carteiras, a criar transações, e também como executar um contrato inteligente básico.

[[ether_units]]
=== Unidades de Moeda Éter

((("currency units")))((("Ethereum (generally)","currency units"))) A unidade monetária da Ethereum é chamada _ether_, identificada também como "ETH&" ou com os símbolos Ξ (da letra grega "Xi&" que se parece com um capital estilizado E) ou, com menos frequência, ♦: por exemplo, 1 éter ou 1 ETH, ou Ξ1, ou ♦ 1.

[DICA]
====
Use o caractere Unicode + U + 039E + para Ξ e + U + 2666 + para ♦.
====

O éter é subdividido em unidades menores, até a menor unidade possível, chamada _wei_. Um éter é 1 quintilhão de wei (1 * 10 ^ 18 ^ ou 1.000.000.000.000.000.000). Você pode ouvir as pessoas se referirem à moeda "Ethereum" também, mas este é um erro comum para iniciantes. Ethereum é o sistema, éter é a moeda.

O valor de éter é sempre representado internamente no Ethereum como um valor inteiro sem sinal codificado em wei. Quando você transaciona 1 éter, a transação codifica 1000000000000000000 wei como o valor.

As várias denominações de Ether têm um nome científico usando o Sistema Internacional de Unidades (ISI) e um nome coloquial que presta homenagem a muitas das grandes mentes da computação e criptografia.

<<ether_denominations>> mostra as várias unidades, seus nomes coloquiais (comuns) e seus nomes de SI. De acordo com a representação interna do valor, a tabela mostra todas as denominações em wei (primeira linha), com éter mostrado como 10 ^ 18 ^ wei na 7ª linha.

[[ether_denominations]]
.Outras denominações e nomes de unidades
[options="header"]
|===
| Valor (em wei) | Expoente Nome comum Nome SI
| 1 | 1 | wei | Wei
| 1,000 | 10^3^ | Babbage | Kilowei or femtoether
| 1,000,000 | 10^6^ | Lovelace | Megawei or picoether
| 1,000,000,000 | 10^9^ | Shannon | Gigawei or nanoether
| 1.000.000.000.000 | 10 ^ 12 ^ | Szabo Microéter ou micro
| 1,000,000,000,000,000 | 10^15^ | Finney | Milliether or milli
| _1,000,000,000,000,000,000_ | _10^18^_ | _Ether_ | _Ether_
| 1,000,000,000,000,000,000,000 | 10^21^ | Grand | Kiloether
| 1,000,000,000,000,000,000,000,000 | 10^24^ | | Megaether
|===

[[choosing_eth_wallet]]
=== Escolhendo uma carteira Ethereum

((("Ethereum (generally)","wallet choices")))((("wallets","choosing")))((("wallets","defined"))) O termo "carteira" chegou significa muitas coisas, embora todas elas estejam relacionadas e no dia-a-dia se resumam à mesma coisa. Usaremos o termo "carteira" para significar um aplicativo de software que ajuda a gerenciar sua conta Ethereum. Em resumo, uma carteira Ethereum é sua porta de entrada para o sistema Ethereum. Ele possui suas chaves e pode criar e transmitir transações em seu nome. A escolha de uma carteira Ethereum pode ser difícil, pois existem muitas opções diferentes com diferentes recursos e designs. Alguns são mais adequados para iniciantes e outros são mais adequados para especialistas. A plataforma Ethereum em si ainda está sendo aprimorada, e as "melhores" carteiras geralmente são as que se adaptam às mudanças que acompanham as atualizações da plataforma.

Mas não se preocupe! Se você escolhe uma carteira e não gosta de como ela funciona - ou se você gosta dela no início, mas depois quer tentar outra coisa - você pode trocar as carteiras facilmente. Tudo o que você precisa fazer é fazer uma transação que envie seus fundos da carteira antiga para a nova carteira ou exportar suas chaves privadas e importá-las para a nova.

Selecionamos três tipos diferentes de carteiras para usar como exemplos ao longo do livro: uma carteira móvel, uma carteira de desktop e uma carteira baseada na Web. Escolhemos essas três carteiras porque elas representam uma ampla gama de complexidade e recursos. No entanto, a seleção dessas carteiras não é um endosso de sua qualidade ou segurança. Eles são simplesmente um bom ponto de partida para demonstrações e testes.

((("private keys","wallets and"))) Lembre-se de que, para que um aplicativo de carteira funcione, ele deve ter acesso às suas chaves privadas; portanto, é vital que você baixe e use apenas aplicativos de carteira de fontes confiáveis. Felizmente, em geral, quanto mais popular é uma aplicação de carteira, mais confiável ela é. No entanto, é uma boa prática evitar "colocar todos os seus ovos em uma cesta" e ter suas contas Ethereum espalhadas por duas carteiras.

A seguir, algumas boas carteiras iniciais:

MetaMask:: ((("MetaMask"))) MetaMask é uma carteira de extensão de navegador executada no seu navegador (Chrome, Firefox, Opera ou Brave Browser). É fácil de usar e conveniente para teste, pois é capaz de se conectar a uma variedade de nós Ethereum e cadeias de blocos de teste. MetaMask é uma carteira baseada na Web.

Jaxx:: ((("Jaxx")))((("wallets","Jaxx"))) O Jaxx é uma carteira multiplataforma e de várias moedas que é executada em uma variedade de sistemas operacionais, incluindo Android, iOS, Windows, macOS, e Linux. Geralmente, é uma boa opção para novos usuários, pois foi projetado para simplicidade e facilidade de uso. O Jaxx é uma carteira móvel ou de desktop, dependendo de onde você a instala.

MyEtherWallet (MEW):: ((("Ethereum Classic (ETC)","Emerald Wallet and")))((("MyEtherWallet (MEW)")))((("wallets","Emerald Wallet")))((("wallets","MyEtherWallet"))) MyEtherWallet é uma carteira baseada na Web que é executada em qualquer navegador. Possui vários recursos sofisticados que exploraremos em muitos de nossos exemplos. MyEtherWallet é uma carteira baseada na Web.

Emerald Wallet:: ((("Emerald Wallet"))) A Emerald Wallet foi projetada para funcionar com o blockchain Ethereum Classic, mas é compatível com outras cadeias de blockchain baseadas no Ethereum. É um aplicativo de desktop de código aberto e funciona no Windows, macOS e Linux. A Emerald Wallet pode executar um nó completo ou conectar-se a um nó remoto público, trabalhando no modo "leve". Ele também possui uma ferramenta complementar para executar todas as operações na linha de comando.

Começaremos instalando o MetaMask em uma área de trabalho - mas primeiro discutiremos brevemente o controle e o gerenciamento de chaves.

[[control_responsibility]]
=== Controle e Responsabilidade

((("Ethereum (generally)","control and responsibility", id="ix_02intro-asciidoc1", range="startofrange"))) As cadeias de blocos abertas como o Ethereum são importantes porque funcionam como um sistema _decentralized_. Isso significa muitas coisas, mas um aspecto crucial é que cada usuário do Ethereum pode - e deve - controlar suas próprias chaves privadas, que são as coisas que controlam o acesso a fundos e contratos inteligentes. Às vezes, chamamos a combinação de acesso a fundos e contratos inteligentes de "conta" ou "carteira". Esses termos podem se tornar bastante complexos em sua funcionalidade; portanto, abordaremos isso com mais detalhes posteriormente. Como princípio fundamental, no entanto, é tão fácil quanto uma chave privada é igual a uma "conta". Alguns usuários optam por abandonar o controle sobre suas chaves privadas usando um custodiante de terceiros, como uma troca on-line. Neste livro, ensinaremos como controlar e gerenciar suas próprias chaves privadas.

Com o controle vem uma grande responsabilidade. Se você perder suas chaves privadas, perderá acesso aos seus fundos e contratos. Ninguém pode ajudá-lo a recuperar o acesso - seus fundos serão bloqueados para sempre. Aqui estão algumas dicas para ajudá-lo a gerenciar essa responsabilidade:

* Não improvise segurança. Use abordagens padrão testadas e testadas.

* Quanto mais importante a conta (por exemplo, quanto maior o valor dos fundos controlados ou mais significativos os contratos inteligentes acessíveis), maiores medidas de segurança devem ser tomadas.

* A segurança mais alta é obtida com um dispositivo com falta de ar, mas esse nível não é necessário para todas as contas.

* Nunca armazene sua chave privada de forma simples, especialmente digitalmente. Felizmente, a maioria das interfaces de usuário hoje nem permite que você veja a chave privada bruta.

* ((("private keys","wallets and"))) As chaves privadas podem ser armazenadas em um formato criptografado, como um arquivo digital "keystore&quot". Sendo criptografados, eles precisam de uma senha para desbloquear. Quando você for solicitado a escolher uma senha, faça-a forte (por exemplo, longa e aleatória), faça backup e não a compartilhe. Se você não possui um gerenciador de senhas, anote-o e guarde-o em um local seguro e secreto. Para acessar sua conta, você precisa do arquivo keystore e da senha.

* Não armazene senhas em documentos digitais, fotos digitais, capturas de tela, unidades on-line, PDFs criptografados, etc. Novamente, não improvise a segurança. Use um gerenciador de senhas ou caneta e papel.

* Quando você for solicitado a fazer backup de uma chave como uma sequência mnemônica de palavras, use papel e caneta para fazer um backup físico. Não deixe essa tarefa "para depois" você esquecerá. Esses backups podem ser usados para reconstruir sua chave privada, caso você perca todos os dados salvos em seu sistema ou se esqueça ou perca sua senha. No entanto, eles também podem ser usados por invasores para obter suas chaves privadas, portanto, nunca as armazene digitalmente e mantenha a cópia física armazenada com segurança em uma gaveta trancada ou segura.

* Antes de transferir grandes quantidades (especialmente para novos endereços), primeiro faça uma pequena transação de teste (por exemplo, valor inferior a US $ 1) e aguarde a confirmação do recebimento.

* Ao criar uma nova conta, comece enviando apenas uma pequena transação de teste para o novo endereço. Depois de receber a transação de teste, tente enviar novamente a partir dessa conta. Há muitas razões pelas quais a criação da conta pode dar errado e, se deu errado, é melhor descobrir com uma pequena perda. Se os testes funcionarem, está tudo bem.

* Exploradores de blocos públicos são uma maneira fácil de verificar independentemente se uma transação foi aceita pela rede. No entanto, essa conveniência tem um impacto negativo na sua privacidade, porque você revela seus endereços para bloquear exploradores, que podem rastrear você.

* Não envie dinheiro para nenhum dos endereços mostrados neste livro. As chaves privadas estão listadas no livro e alguém receberá imediatamente esse dinheiro.

Agora que abordamos algumas práticas recomendadas básicas para gerenciamento e segurança de chaves, vamos trabalhar com o MetaMask! (((range="endofrange", startref="ix_02intro-asciidoc1")))

[[installing_MetaMask]]
=== Introdução ao MetaMask

((("Ethereum (generally)","MetaMask basics", id="ix_02intro-asciidoc2", range="startofrange")))((("MetaMask","basics", id="ix_02intro-asciidoc3", range="startofrange"))) Abra o navegador Google Chrome e navegue até https://chrome.google.com/webstore/category/extensions [].

Procure por "MetaMask" e clique no logotipo de uma raposa. Você deve ver algo como o resultado mostrado em <<metamask_download>>.

[[metamask_download]]
.A página de detalhes da extensão do MetaMask Chrome
image::images/metamask_download.png["MetaMask Detail Page"]

É importante verificar se você está baixando a extensão real do MetaMask, pois às vezes as pessoas conseguem furtar extensões maliciosas pelos filtros do Google. O Real:

* Mostra o ID + nkbihfbeogaeaoehlefnkodbefgpgknn + na barra de endereço
* É oferecido por https://metamask.io
* Possui mais de 1.500 avaliações
* Possui mais de 1.000.000 de usuários

Depois de confirmar que você está procurando a extensão correta, clique em "Adicionar ao Chrome" para instalá-la.

[[using_MetaMask]]
==== Criando uma carteira

((("MetaMask","wallet setup with", id="ix_02intro-asciidoc4", range="startofrange"))) Depois que o MetaMask estiver instalado, você verá um novo ícone (a cabeça de uma raposa) na barra de ferramentas do navegador . Clique nele para começar. Você será solicitado a aceitar os termos e condições e criar sua nova carteira Ethereum digitando uma senha (consulte <<metamask_password>>).

[[metamask_password]]
.A página de senha da extensão do MetaMask Chrome
image::images/metamask_password.png["MetaMask Password Page"]

[DICA]
====
A senha controla o acesso ao MetaMask, para que não possa ser usado por ninguém com acesso ao seu navegador.
====

((("mnemonic code words","MetaMask and", id="ix_02intro-asciidoc5", range="startofrange"))) Depois de definir uma senha, o MetaMask irá gerar uma carteira para você e mostrar um _mnemônico backup_ composto por 12 palavras em inglês (consulte  <<metamask_mnemonic>>). Essas palavras podem ser usadas em qualquer carteira compatível para recuperar o acesso aos seus fundos, caso algo aconteça ao MetaMask ou ao seu computador. Você não precisa da senha para esta recuperação; as 12 palavras são suficientes.

[DICA]
====
Faça backup do seu mnemônico (12 palavras) no papel, duas vezes. Armazene os dois backups em papel em dois locais seguros separados, como um cofre resistente ao fogo, uma gaveta trancada ou um cofre. Trate os backups em papel como dinheiro de valor equivalente ao que você armazena em sua carteira Ethereum. Qualquer pessoa com acesso a essas palavras pode obter acesso e roubar seu dinheiro.
====

[[metamask_mnemonic]]
.O backup mnemônico da sua carteira, criado pelo MetaMask
image::images/metamask_mnemonic.png["MetaMask Mnemonic Page"]

Depois de confirmar que você armazenou o mnemônico de forma segura, poderá ver os detalhes da sua conta Ethereum, conforme mostrado em <<metamask_account>>. (((range="endofrange", startref="ix_02intro-asciidoc5")))

[[metamask_account]]
.Sua conta do Ethereum no MetaMask
image::images/metamask_account.png["MetaMask Account Page"]

A página da sua conta mostra o nome da sua conta ("Conta 1" por padrão), um endereço Ethereum (+ 0x9E713 ... + no exemplo) e um ícone colorido para ajudá-lo a distinguir visualmente essa conta de outras contas. Na parte superior da página da conta, você pode ver em qual rede Ethereum você está trabalhando ("Rede principal" no exemplo).

Parabéns! Você configurou sua primeira carteira Ethereum. (((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Redes de comutação

((("MetaMask","network choices"))) Como você pode ver na página da conta MetaMask, você pode escolher entre várias redes Ethereum. Por padrão, o MetaMask tentará se conectar à rede principal. As outras opções são redes de teste públicas, qualquer nó Ethereum de sua escolha ou nós executando cadeias de blocos privadas em seu próprio computador (host local):

Principal rede Ethereum :: A principal blockchain pública da Ethereum. ETH real, valor real e consequências reais.

Ropsten Test Network :: blockchain e rede de teste público Ethereum. ETH nesta rede não tem valor.

Rede de teste Kovan :: blockchain e rede de teste público Ethereum usando o protocolo de consenso da Aura com prova de autoridade (assinatura federada). ETH nesta rede não tem valor. A rede de teste Kovan é suportada apenas pelo Parity. Outros clientes Ethereum usam o protocolo de consenso Clique, proposto posteriormente, para comprovação de verificação baseada em autoridade.

Rede de teste Rinkeby :: blockchain e rede de teste público Ethereum, usando o protocolo de consenso Clique com prova de autoridade (assinatura federada). ETH nesta rede não tem valor.

Localhost 8545 :: Conecta-se a um nó em execução no mesmo computador que o navegador. O nó pode fazer parte de qualquer blockchain pública (principal ou testnet) ou de uma rede de teste privada.

RPC personalizado :: Permite conectar o MetaMask a qualquer nó com uma interface RPC (Remote Procedure Call) compatível com Geth. O nó pode fazer parte de qualquer blockchain pública ou privada.

[NOTE]
====
Sua carteira MetaMask usa a mesma chave privada e endereço Ethereum em todas as redes às quais ele se conecta. No entanto, o saldo do seu endereço Ethereum em cada rede Ethereum será diferente. Suas chaves podem controlar o éter e os contratos no Ropsten, por exemplo, mas não na rede principal.
====

[[getting_test_eth]]
==== Obtendo Algum Éter de Teste

((("ether (generally)","testnet")))((("MetaMask","and testnet ether")))((("test ether","obtaining")))((("testnet","ether for")))((("wallets","testnet ether and"))) Sua primeira tarefa é obter sua carteira financiada. Você não fará isso na rede principal porque o éter real custa dinheiro e o manuseio exige um pouco mais de experiência. Por enquanto, você carregará sua carteira com um pouco de éter de rede de teste.

((("Ropsten Test Network"))) Mude a MetaMask para a _Ropsten Test Network_. Clique em Depósito e clique em Torneira de teste Ropsten. O MetaMask abrirá uma nova página da web, como mostrado em <<metamask_ropsten_faucet>>.

[[metamask_ropsten_faucet]]
Torneira de teste de Ropsten .MetaMask
image::images/metamask_ropsten_faucet.png["MetaMask Ropsten Test Faucet"]

Você pode perceber que a página da web já contém o endereço Ethereum da sua carteira MetaMask. O MetaMask integra páginas da Web ativadas para Ethereum à sua carteira MetaMask e pode &quot;ver&quot; os endereços Ethereum na página da Web, permitindo, por exemplo, enviar um pagamento para uma loja online que exibe um endereço Ethereum. O MetaMask também pode preencher a página da web com o endereço da sua própria carteira como endereço de destinatário, se a página da web solicitar. Nesta página, o aplicativo de torneira está solicitando ao MetaMask um endereço de carteira para enviar o éter de teste.

Clique no botão verde &quot;solicitar 1 éter da torneira&quot;. Você verá um ID da transação na parte inferior da página. O aplicativo torneira criou uma transação - um pagamento para você. O ID da transação é assim:

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

Em alguns segundos, a nova transação será extraída pelos mineradores Ropsten e sua carteira MetaMask exibirá um saldo de 1 ETH. Clique no ID da transação e seu navegador o levará a um _block explorer_, que é um site que permite visualizar e explorar blocos, endereços e transações. O MetaMask usa o https://etherscan.io/[Etherscan block explorer], um dos mais populares exploradores de blocos Ethereum. A transação que contém o pagamento do Ropsten Test Faucet é mostrada em  <<ropsten_block_explorer>>.

[[ropsten_block_explorer]]
.Etherscan Ropsten block explorer
image::images/ropsten_block_explorer.png["Etherscan Ropsten Block Explorer"]

A transação foi registrada na blockchain Ropsten e pode ser visualizada a qualquer momento por qualquer pessoa, simplesmente pesquisando o ID da transação ou http://bit.ly/2Q860Wk[visando o link].

Tente visitar esse link ou inserir o hash da transação no site _ropsten.etherscan.io_, para ver por si mesmo.

[[sending_eth_MetaMask]]
==== Enviando Ether do MetaMask

((("MetaMask","sending ether from", id="ix_02intro-asciidoc6", range="startofrange")))((("test ether","sending", id="ix_02intro-asciidoc7", range="startofrange"))) Depois de receber seu primeiro éter de teste da torneira de teste de Ropsten, você pode experimentar o envio de éter tentando enviar alguns de volta para a torneira. Como você pode ver na página Ropsten Test Faucet, há uma opção para "doar" 1 ETH à torneira. Essa opção está disponível para que, assim que você concluir o teste, você possa retornar o restante do seu éter de teste, para que outra pessoa possa usá-lo em seguida. Embora o éter de teste não tenha valor, algumas pessoas o armazenam, dificultando o uso de outras redes de teste por todos os outros. O teste de acumulação de éter é desaprovado!

Felizmente, não somos acumuladores de éter de teste. Clique no botão laranja "1 éter" para dizer ao MetaMask para criar uma transação que pague a torneira 1 éter. O MetaMask preparará uma transação e abrirá uma janela com a confirmação, conforme mostrado em  <<send_to_faucet>>.


[[send_to_faucet]]
Enviar 1 éter para a torneira
image::images/send_to_faucet.png["Sending 1 ether to the faucet"]

Opa! Você provavelmente notou que não pode concluir a transação - o MetaMask diz que você tem um saldo insuficiente. À primeira vista, isso pode parecer confuso: você tem 1 ETH, deseja enviar 1 ETH, então por que o MetaMask está dizendo que você tem fundos insuficientes?

((("gas","basics"))) A resposta é devido ao custo de _gas_. Toda transação Ethereum exige o pagamento de uma taxa, que é coletada pelos mineradores para validar a transação. As taxas no Ethereum são cobradas em uma moeda virtual chamada gás. Você paga pelo gás com éter, como parte da transação.

[NOTE]
====
((("gas","on test networks"))) Também são necessárias taxas nas redes de teste. Sem taxas, uma rede de teste se comportaria de maneira diferente da rede principal, tornando-a uma plataforma de teste inadequada. As taxas também protegem as redes de teste contra ataques de negação de serviço e contratos mal construídos (por exemplo, loops infinitos), da mesma forma que protegem a rede principal.
====

Quando você enviou a transação, o MetaMask calculou o preço médio do gás das transações bem-sucedidas recentes em 3 gwei, o que significa gigawei. Wei é o menor passo: [ <span class="keep-together">subdivisão</span> ] da moeda éter, como discutimos em <<ether_units>>. O limite de gás é definido ao custo do envio de uma transação básica, que é 21.000 unidades de gás. Portanto, a quantidade máxima de ETH que você gastará é 3 * 21.000 gwei = 63.000 gwei = 0,000063 ETH. (Esteja ciente de que os preços médios do gás podem variar, pois são predominantemente determinados por mineradoras. Veremos em um capítulo posterior como você pode aumentar / diminuir seu limite de gás para garantir que sua transação tenha precedência, se necessário.)

Tudo isso a dizer: fazer uma transação com 1 ETH custa 1.000063 ETH. O MetaMask arredonda confusamente esse _down_ para 1 ETH ao mostrar o total, mas a quantidade real necessária é 1.000063 ETH e você só tem 1 ETH. Clique em Rejeitar para cancelar esta transação.

Vamos pegar mais um éter de teste! Clique no botão verde "solicitar 1 éter da torneira" novamente e aguarde alguns segundos. Não se preocupe, a torneira deve ter bastante éter e lhe dará mais se você perguntar.

Depois de ter um saldo de 2 ETH, você pode tentar novamente. Dessa vez, quando você clica no botão laranja de doação &quot;1 éter&quot;, você tem saldo suficiente para concluir a transação. Clique em Enviar quando o MetaMask abrir a janela de pagamento. Depois de tudo isso, você verá um saldo de 0,999937 ETH porque enviou 1 ETH à torneira com 0,000063 ETH no gás.(((range="endofrange", startref="ix_02intro-asciidoc7")))(((range="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Explorando o histórico de transações de um endereço

((("addresses","exploring transaction history of", id="ix_02intro-asciidoc8", range="startofrange")))((("MetaMask","exploring transaction history of an address with", id="ix_02intro-asciidoc9", range="startofrange"))) A partir de agora você se tornou um especialista no uso do MetaMask para enviar e receber éter de teste. Sua carteira recebeu pelo menos dois pagamentos e enviou pelo menos um. Você pode visualizar todas essas transações usando o explorador de blocos _ropsten.etherscan.io_. Você pode copiar o endereço da sua carteira e colá-lo na caixa de pesquisa do explorador de blocos ou fazer com que o MetaMask abra a página para você. Ao lado do ícone da sua conta no MetaMask, você verá um botão mostrando três pontos. Clique nele para exibir um menu de opções relacionadas à conta (consulte  <<metamask_account_context_menu>>).

[[metamask_account_context_menu]]
Menu de contexto da conta .MetaMask
image::images/metamask_account_context_menu.png["MetaMask Account Context Menu"]

Selecione  "Visualizar conta no Etherscan" para abrir uma página da web no explorador de blocos, mostrando o histórico de transações da sua conta, conforme mostrado em <<block_explorer_account_history>>.

[[block_explorer_account_history]]
Histórico de transações do endereço no Etherscan
image::images/block_explorer_account_history.png["Address Transaction History on Etherscan"]

Aqui você pode ver todo o histórico de transações do seu endereço Ethereum. Ele mostra todas as transações registradas na blockchain Ropsten em que seu endereço é o remetente ou destinatário. Clique em algumas dessas transações para ver mais detalhes.

Você pode explorar o histórico de transações de qualquer endereço. Veja o histórico de transações do endereço Ropsten Test Faucet (dica: é o endereço "remetente" listado no pagamento mais antigo do seu endereço). Você pode ver todo o éter de teste enviado da torneira para você e para outros endereços. Toda transação que você vê pode levá-lo a mais endereços e mais transações. Em pouco tempo você estará perdido no labirinto de dados interconectados. As blockchains públicas contêm uma enorme riqueza de informações, todas as quais podem ser exploradas programaticamente, como veremos em exemplos futuros (((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange", startref="ix_02intro-asciidoc8"))).(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Apresentando o Computador Mundial

((("Ethereum (generally)","and EVM")))((("EVM (Ethereum Virtual Machine)","as world computer")))((("world computer, Ethereum as"))) Agora você criou uma carteira e enviou e recebeu éter. Até agora, tratamos o Ethereum como uma criptomoeda. Mas o Ethereum é muito, muito mais. De fato, a função de criptomoeda é subserviente à função da Ethereum como um computador mundial descentralizado. ((("smart contracts","ether and"))) O Ether deve ser usado para pagar pela execução de  _contratos inteligentes_, que são programas de computador executados em um computador emulado chamado _Ethereum Virtual Machine_ (EVM).

O EVM é um singleton global, o que significa que opera como se fosse um computador global de instância única, rodando em qualquer lugar. Cada nó na rede Ethereum executa uma cópia local do EVM para validar a execução do contrato, enquanto o blockchain Ethereum registra a mudança de estado deste computador mundial enquanto processa transações e contratos inteligentes. Discutiremos isso com muito mais detalhes em <<evm_chapter>>.

[[EOA_contracts]]
=== Contas de propriedade externa (EOAs) e contratos

((("contract accounts", seealso="smart contracts")))((("EOA (Externally Owned Account)","basics")))((("Ethereum (generally)","EOAs and contracts")))((("smart contracts","basics"))) O tipo de conta que você criou na carteira MetaMask é chamada de _Eternamente possuída_ conta (EOA). Contas de propriedade externa são aquelas que possuem uma chave privada; ter a chave privada significa controle sobre o acesso a fundos ou contratos. Agora, você provavelmente está supondo que exista outro tipo de conta. Esse outro tipo de conta é uma _contrate account_. Uma conta de contrato possui um código de contrato inteligente, que um EOA simples não pode ter. Além disso, uma conta de contrato não possui uma chave privada. Em vez disso, ele pertence (e é controlado) pela lógica de seu código de contrato inteligente: o programa de software gravado no blockchain Ethereum na criação da conta do contrato e executado pelo EVM.

Os contratos têm endereços, assim como os EOAs. Os contratos também podem enviar e receber éter, assim como os EOAs. No entanto, quando um destino de transação é um endereço de contrato, ele faz com que _run_ seja executado no EVM, usando a transação e os dados da transação como entrada. Além do éter, as transações podem conter _dados_ indicando qual função específica do contrato executar e quais parâmetros passar para essa função. Dessa maneira, as transações podem chamar funções dentro de contratos.

Observe que, como uma conta de contrato não possui uma chave privada, ela não pode iniciar uma transação. Somente os EOAs podem iniciar transações, mas os contratos podem reagir às transações chamando outros contratos, criando caminhos de execução complexos. Um uso típico disso é um EOA enviando uma transação de solicitação para uma carteira de contrato inteligente com várias assinaturas para enviar um ETH para outro endereço. Um padrão de programação típico do DApp é ter o Contrato A chamando o Contrato B para manter um estado compartilhado entre os usuários do Contrato A.

Nas próximas seções, escreveremos nosso primeiro contrato. Você aprenderá como criar, financiar e usar esse contrato com sua carteira MetaMask e testar o éter na rede de testes Ropsten.

[[simple_contract_example]]
=== Um contrato simples: uma torneira de éter de teste

((("contract accounts","creating", seealso="Faucet.sol contract", id="ix_02intro-asciidoc10", range="startofrange")))((("Faucet.sol contract (test example)","creating", id="ix_02intro-asciidoc11", range="startofrange"))) O Ethereum possui muitos idiomas de alto nível diferentes, os quais podem ser usados para escrever um contrato e produzir o bytecode EVM. Você pode ler sobre muitos dos mais importantes e interessantes de  <<high_level_languages>>. Uma linguagem de alto nível é de longe a escolha dominante para a programação inteligente de contratos: Solidity.  ((("Wood, Dr. Gavin","and Solidity"))) O Solidity foi criado pelo Dr. Gavin Wood, co-autor deste livro, e tornou-se a linguagem mais usada no Ethereum (e além). Usaremos o Solidity para escrever nosso primeiro contrato.

((("Solidity","faucet.sol and"))) Para o nosso primeiro exemplo (<<solidity_faucet_example>>), escreveremos um contrato que controla um _faucet_. Você já usou uma torneira para obter éter de teste na rede de testes da Ropsten. Uma torneira é uma coisa relativamente simples: dá éter a qualquer endereço que pergunte e pode ser recarregada periodicamente. Você pode implementar uma torneira como uma carteira controlada por um humano ou um servidor da web.

[[solidity_faucet_example]]
.Faucet.sol: contrato de solidez que implementa uma torneira
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
Você encontrará todos os exemplos de código deste livro no subdiretório _code_ do https://github.com/ethereumbook/ethereumbook/[ repositório GitHub do livro]. Especificamente, nosso contrato _Faucet.sol_ está em:

----
code/Solidity/Faucet.sol
----
====

Este é um contrato muito simples, o mais simples que podemos fazer. Também é um contrato falho, demonstrando várias práticas ruins e vulnerabilidades de segurança. Aprenderemos examinando todas as suas falhas nas seções posteriores. Mas, por enquanto, vejamos o que esse contrato faz e como ele funciona, linha por linha. Você notará rapidamente que muitos elementos do Solidity são semelhantes às linguagens de programação existentes, como JavaScript, Java ou Cpass: [++].

A primeira linha é um comentário:

[[comment]]
[source,solidity]
----
// Our first contract is a faucet!
----

Os comentários são para humanos lerem e não estão incluídos no bytecode executável do EVM. Geralmente, os colocamos na linha antes do código que estamos tentando explicar, ou às vezes na mesma linha. Os comentários começam com duas barras: +//+. Tudo, desde a primeira barra até o final dessa linha, é tratado da mesma forma que uma linha em branco e ignorado.

A próxima linha é onde o contrato real começa:

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

Essa linha declara um objeto +contract+, semelhante a uma declaração +class+ em outras linguagens orientadas a objetos. A definição do contrato inclui todas as linhas entre os chavetas (passagem: [ <code>{}</code> ]), que definem um _scope_, assim como as chaves são usadas em muitas outras linguagens de programação.

Next, we declare the first function of the +Faucet+ contract:

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

A função é denominada +retirada+ e leva um argumento inteiro não assinado (+uint+) chamado+ quantidade_ retirada+. É declarado como uma função pública, o que significa que pode ser chamado por outros contratos. A definição da função segue, entre chaves. A primeira parte da função +retirada+ define um limite para retiradas:

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

Ele usa a função Solidity integrada + require + para testar uma pré-condição, que o valor de retirada + é menor ou igual a 100.000.000.000.000.000 wei, que é a unidade base de éter (consulte <<ether_denominations>>) e equivalente a 0,1 éter. Se a função + retirar + for chamada com uma quantidade + retirar + maior que esse valor, a função + exigir + aqui fará com que a execução do contrato pare e falhe com uma _exceção_. Observe que as instruções precisam ser encerradas com um ponto-e-vírgula no Solidity.

Esta parte do contrato é a principal lógica da nossa torneira. Ele controla o fluxo de fundos do contrato, colocando um limite para saques. É um controle muito simples, mas pode lhe dar uma idéia do poder de uma blockchain programável: software descentralizado que controla dinheiro.

Em seguida, vem a retirada real:

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Algumas coisas interessantes estão acontecendo aqui. O objeto + msg + é uma das entradas que todos os contratos podem acessar. Representa a transação que acionou a execução deste contrato. O atributo + remetente + é o endereço do remetente da transação. A função + transferência + é uma função interna que transfere o éter do contrato atual para o endereço do remetente. Lendo para trás, isso significa + transferir + para o + remetente + do + msg + que acionou a execução do contrato. A função + transfere + assume uma quantidade como seu único argumento. Passamos o valor de + retirada_ quantidade + que foi o parâmetro para a função + retirada + declarada algumas linhas anteriormente.

A linha seguinte é a chave de fechamento, indicando o final da definição de nossa função +retirar+.

Em seguida, declaramos mais uma função:

[[fallback_function]]
[source,solidity]
----
function () external payable {}
----

((("fallback function")))This function is a so-called _fallback_ or _default_ function, which is called if the transaction that triggered the contract didn't name any of the declared functions in the contract, or any function at all, or didn't contain data. Contracts can have one such default function (without a name) and it is usually the one that receives ether. That's why it is defined as an external and payable function, which means it can accept ether into the contract. It doesn't do anything, other than accept the ether, as indicated by the empty definition in the curly braces pass:[(<code>{}</code>)]. If we make a transaction that sends ether to the contract address, as if it were a wallet, this function will handle it.

Right below our default function is the final closing curly brace, which closes the definition of the contract +Faucet+. That's it!(((range="endofrange", startref="ix_02intro-asciidoc11")))(((range="endofrange", startref="ix_02intro-asciidoc10")))

[[compile_faucet_contract]]
=== Compilando o contrato de torneira

((("compiling","Faucet.sol contract", id="ix_02intro-asciidoc12", range="startofrange")))((("Faucet.sol contract (test example)","compiling", id="ix_02intro-asciidoc13", range="startofrange")))Now that we have our first example contract, we need to use a Solidity compiler to convert the Solidity code into EVM bytecode so it can be executed by the EVM on the blockchain itself.

O compilador Solidity vem como um executável independente, como parte de várias estruturas, e empacotado em Ambientes de Desenvolvimento Integrado (IDEs). Para simplificar, usaremos um dos IDEs mais populares, chamado _Remix_.

((("Remix IDE"))) Use o navegador Chrome (com a carteira MetaMask instalada anteriormente) para navegar até o Remix IDE em https://remix.ethereum.org [].

Quando você carrega o Remix pela primeira vez, ele começa com um contrato de amostra chamado _ballot.sol_. Não precisamos disso, então feche-o clicando no + x + no canto da guia, como visto em  <<remix_close_tab>>.

[[remix_close_tab]]
.Feche a guia de exemplo padrão
image::images/remix_close_tab.png["Close the default example tab"]

Agora, adicione uma nova guia clicando no sinal de mais circular na barra de ferramentas superior esquerda, como visto em <<remix_toolbar>>.  Nomeie o novo arquivo _Faucet.sol_.

[[remix_toolbar]]
.Clique no sinal de adição para abrir uma nova guia
image::images/remix_toolbar.png["Click the plus sign to open a new tab"]

Once you have the new tab open, copy and paste the code from our example _Faucet.sol_, as seen in <<remix_faucet_load>>.

[[remix_faucet_load]]
.Copie o código de exemplo Torneira para a nova guia
image::images/remix_faucet_load.png["Copy the Faucet example code into the new tab"]

Once you have loaded the _Faucet.sol_ contract into the Remix IDE, the IDE will automatically compile the code. If all goes well, you will see a green box with "Faucet" in it appear on the right, under the Compile tab, confirming the successful compilation (see <<remix_compile>>).

[[remix_compile]]
.Remix compila com sucesso o contrato Faucet.sol
image::images/remix_compile.png[""]

Se algo der errado, o problema mais provável é que o Remix IDE esteja usando uma versão do compilador Solidity diferente da 0.5.12. Nesse caso, nossa diretiva pragma impedirá a compilação de _Faucet.sol_. Para alterar a versão do compilador, vá para a guia Configurações, defina a versão para 0.5.12 e tente novamente.

O compilador Solidity agora compilou nosso _Faucet.sol_ no bytecode do EVM. Se você estiver curioso, o bytecode será assim:

[[faucet_bytecode]]
----
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST PUSH1 0xE5 DUP1 PUSH2 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN
STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3F JUMPI
PUSH1 0x0 CALLDATALOAD PUSH29
0x100000000000000000000000000000000000000000000000000000000
SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x41 JUMPI
JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH1 0x4B JUMPI PUSH1 0x0 DUP1 REVERT
JUMPDEST PUSH1 0x5F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1
SWAP2 SWAP1 POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8
0x16345785D8A0000 DUP2 GT ISZERO ISZERO ISZERO PUSH1 0x77 JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND
PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1
0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO
ISZERO PUSH1 0xB6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP STOP LOG1 PUSH6
0x627A7A723058 KECCAK256 PUSH9 0x13D1EA839A4438EF75 GASLIMIT CALLVALUE LOG4 0x5f
PUSH24 0x7541F409787592C988A079407FB28B4AD000290000000000
----

Aren't you glad you are using a high-level language like Solidity instead of programming directly in EVM bytecode? Me too!(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Criando o contrato no Blockchain

((("blockchain","creating contract on", id="ix_02intro-asciidoc14", range="startofrange")))((("Faucet.sol contract (test example)","on the blockchain", id="ix_02intro-asciidoc15", range="startofrange")))So, we have a contract. We've compiled it into bytecode. Now, we need to "register" the contract on the Ethereum blockchain. We will be using the Ropsten testnet to test our contract, so that's the blockchain we want to submit it to.

((("zero address","contract registration")))Registering a contract on the blockchain involves creating a special transaction whose destination is the address +0x0000000000000000000000000000000000000000+, also known as the _zero address_. The zero address is a special address that tells the Ethereum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask.

((("Remix IDE", id="ix_02intro-asciidoc16", range="startofrange")))First, switch to the Run tab and select Injected Web3 in the Environment drop-down selection box. This connects the Remix IDE to the MetaMask wallet, and through MetaMask to the Ropsten test network. Once you do that, you can see Ropsten under Environment. Also, in the Account selection box it shows the address of your wallet (see <<remix_run>>).

[[remix_run]]
.Remix IDE Run tab, with Injected Web3 environment selected
image::images/remix_run.png["Remix IDE Run tab, with Injected Web3 environment selected"]

Right below the Run settings you just confirmed is the +Faucet+ contract, ready to be created. Click on the Deploy button shown in <<remix_run>>.

Remix will construct the special "creation" transaction and MetaMask will ask you to approve it, as shown in <<remix_metamask_create>>. You'll notice the contract creation transaction has no ether in it, but it has 262 bytes of data (the compiled contract) and will consume 10 gwei in gas. Click Submit to approve it.

[[remix_metamask_create]]
.MetaMask mostrando a transação de criação do contrato
image::images/remix_metamask_create.png["MetaMask showing the contract creation transaction"]

Agora você tem que esperar. Levará cerca de 15 a 30 segundos para que o contrato seja extraído na Ropsten. Remix não parece estar fazendo muito, mas seja paciente.

Once the contract is created, it appears at the bottom of the Run tab (see <<remix_contract_interact>>).

[[remix_contract_interact]]
O contrato da torneira está VIVO!
image::images/remix_contract_interact.png["The Faucet contract is ALIVE!"]

Notice that the +Faucet+ contract now has an address of its own: Remix shows it as &#x201c;Faucet at 0x72e...c7829&#x201d; (although your address, the random letters and numbers, will be different). The small clipboard symbol to the right allows you to copy the contract address to your clipboard. We will use that in the next section.(((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Interagindo com o Contrato

((("Faucet.sol contract (test example)","interacting with", id="ix_02intro-asciidoc17", range="startofrange")))Let's recap what we've learned so far: Ethereum contracts are programs that control money, which run inside a virtual machine called the EVM. They are created by a special transaction that submits their bytecode to be recorded on the blockchain. Once they are created on the blockchain, they have an Ethereum address, just like wallets. Anytime someone sends a transaction to a contract address it causes the contract to run in the EVM, with the transaction as its input. Transactions sent to pass:[<span class="keep-together">contract</span>] addresses may have ether or data or both. If they contain ether, it is "deposited" to the contract balance. If they contain data, the data can specify a named function in the contract and call it, passing arguments to the function.

[[view_contract_address]]
==== Visualizando o endereço do contrato em um Block Explorer

((("Faucet.sol contract (test example)","viewing contract address in a block explorer")))We now have a contract recorded on the blockchain, and we can see it has an Ethereum address. Let's check it out in the _ropsten.etherscan.io_ block explorer and see what a contract looks like. In the Remix IDE, copy the address of the contract by clicking the clipboard icon next to its name (see <<remix_contract_address>>).

[[remix_contract_address]]
.Copie o endereço do contrato no Remix
image::images/remix_contract_address.png["Copy the contract address from Remix"]

Keep Remix open; we'll come back to it again later. Now, navigate your browser to _ropsten.etherscan.io_ and paste the address into the search box. You should see the contract's Ethereum address history, as shown in <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.Ver o endereço do contrato da Torneira no explorador de blocos Etherscan
image::images/etherscan_contract_address.png["View the Faucet contract address in the etherscan block explorer"]

[[fund_contract]]
==== Financiamento do contrato

((("Faucet.sol contract (test example)","sending ether to", id="ix_02intro-asciidoc18", range="startofrange")))For now, the contract only has one transaction in its history: the contract creation transaction. As you can see, the contract also has no ether (zero balance). That's because we didn't send any ether to the contract in the creation transaction, even though we could have.

Our faucet needs funds! Our first project will be to use MetaMask to send ether to the contract. You should still have the address of the contract in your clipboard (if not, copy it again from Remix). Open MetaMask, and send 1 ether to it, exactly as you would to any other Ethereum address (see <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
.Envie 1 éter para o endereço do contrato
image::images/metamask_send_to_contract.png[""]

Em um minuto, se você recarregar o Etherscan block explorer, ele mostrará outra transação para o endereço do contrato e um saldo atualizado de 1 éter.

Lembre-se da função externa pagável padrão sem nome em nosso código _Faucet.sol_? Parecia assim:

[[fallback_function_review]]
[source,solidity]
----
function () external payable {}
----

When you sent a transaction to the contract address, with no data specifying which function to call, it called this default function. Because we declared it as +payable+, it accepted and deposited the 1 ether into the contract's account balance. Your transaction caused the contract to run in the EVM, updating its balance. You have funded your faucet!(((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Retirada de nosso contrato

((("Faucet.sol contract (test example)","withdrawing funds from", id="ix_02intro-asciidoc19", range="startofrange")))((("withdrawal of funds from contract", id="ix_02intro-asciidoc20", range="startofrange")))Next, let's withdraw some funds from the faucet. To withdraw, we have to construct a transaction that calls the +withdraw+ function and passes a +withdraw_amount+ argument to it. To keep things simple for now, Remix will construct that transaction for us and MetaMask will present it for our approval.

Return to the Remix tab and look at the contract on the Run tab. You should see a orange box labeled +withdraw+ with a field entry labeled +uint256 withdraw_amount+ (see <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
.A função de retirada do Faucet.sol, no Remix
image::images/remix_contract_interact.png["The withdraw function of Faucet.sol, in Remix"]

Esta é a interface Remix para o contrato. Isso nos permite construir transações que chamam as funções definidas no contrato. Digitaremos um +número_decisão+ e clicaremos no botão retirar para gerar a transação.

Primeiro, vamos descobrir o +retirada_quantidade+. Queremos tentar retirar 0,1 éter, que é o valor máximo permitido pelo nosso contrato. Lembre-se de que todos os valores de moeda no Ethereum são denominados em wei internamente, e nossa função +retirada+espera que o valor+quantidade retirada também seja denominado em wei. A quantidade que queremos é 0,1 éter, que é 100.000.000.000.000.000 wei (1 seguido de 17 zeros).



[DICA]
====
Due to a limitation in JavaScript, a number as large as 10^17 cannot be processed by Remix. Instead, we enclose it in double quotes, to allow Remix to receive it as a string and manipulate it as a +BigNumber+. If we don't enclose it in quotes, the Remix IDE will fail to process it and display "Error encoding arguments: Error: Assertion failed."
====

Type "100000000000000000" (with the quotes) into the +withdraw_amount+ box and click on the withdraw button (see <<remix_withdraw>>).

[[remix_withdraw]]
.Click "withdraw" in Remix to create a withdrawal transaction
image::images/remix_withdraw.png[""]

MetaMask will pop up a transaction window for you to approve. Click Confirm to send your withdrawal call to the contract (see <<metamask_withdraw>>).

[[metamask_withdraw]]
Transação .MetaMask para chamar a função de retirada
image::images/metamask_withdraw.png["MetaMask transaction to call the withdraw function"]

Wait a minute and then reload the Etherscan block explorer to see the transaction reflected in the +Faucet+ contract address history (see <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan mostra a transação que chama a função de retirada
image::images/etherscan_withdrawal_tx.png["Etherscan shows the transaction calling the withdraw function"]


Agora vemos uma nova transação com o endereço do contrato como destino e um valor de 0 éter. O saldo do contrato mudou e agora é de 0,9 éter porque nos enviou 0,1 éter conforme solicitado. Mas não vemos uma transação &quot;OUT&quot; no _history do endereço do contrato_.

Where's the outgoing withdrawal? A new tab has appeared on the contract's address history page, named Internal Transactions. ((("internal transaction (message)")))Because the 0.1 ether transfer originated from the contract code, it is an internal transaction (also called a _message_). Click on that tab to see it (see <<etherscan_withdrawal_internal>>).


This "internal transaction" was sent by the contract in this line of code (from the pass:[<code><span class="keep-together">withdraw</span></code>] function in _Faucet.sol_):

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

To recap: you sent a transaction from your MetaMask wallet that contained data instructions to call the +withdraw+ function with a +withdraw_amount+ argument of 0.1 ether. That transaction caused the contract to run inside the EVM. As the EVM ran the +Faucet+ contract's +withdraw+ function, first it called the +require+ function and validated that the requested amount was less than or equal to the maximum allowed withdrawal of 0.1 ether. Then it called the +transfer+ function to send you the ether. Running the +transfer+ function generated an internal transaction that deposited 0.1 ether into your wallet address, from the contract's balance. That's the one shown on the Internal Transactions tab in Etherscan(((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))).(((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan mostra a transação interna que transfere o éter do contrato
image::images/etherscan_withdrawal_internal.png["Etherscan shows the internal transaction transferring ether out from the contract"]

[[intro_conclusion]]
=== Conclusões

Neste capítulo, você configurou uma carteira usando o MetaMask e a financiou usando uma torneira na rede de teste da Ropsten. Você recebeu o éter no endereço Ethereum da sua carteira e enviou o éter para o endereço Ethereum da torneira.

Next, you wrote a faucet contract in Solidity. You used the Remix IDE to compile the contract into EVM bytecode, then used Remix to form a transaction and created the +Faucet+ contract on the Ropsten blockchain. Once created, the +Faucet+ contract had an Ethereum address, and you sent it some ether. Finally, you constructed a transaction to call the +withdraw+ function and successfully asked for 0.1 ether. The contract checked the request and sent you 0.1 ether with an internal transaction.

Pode não parecer muito, mas você acabou de interagir com sucesso com o software que controla o dinheiro em um computador mundial descentralizado.

We will do a lot more smart contract programming in <<smart_contracts_chapter>> and learn about best practices and security considerations in <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))