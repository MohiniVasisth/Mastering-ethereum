[role="pagenumrestart"]
[[whatis_chapter]]
이더리움은 무엇인가?

 이더리움은 종종 "세계 컴퓨터201" 로 묘사됨니다. 하지만 이것이 무엇을 뜻할까요? 컴퓨터 과학에 초점을 맞춘 설명으로 시작한 다음 이더리움의 기능과 특성에 대한보다 실용적인 분석을 통해 이를 해독하고 비트코인 및 기타 분산형 정보교환 플랫폼(이하 "블록체인")과 비교해 보겠습니다.

컴퓨터 과학 관점에서 이더 리움은 결정론적이지만 사실상 제한되지 않은 상태 머신으로, 전역적으로 액세스 가능한 싱글톤 상태와 해당 상태에 변경 사항을 적용하는 가상머신으로 구성됩니다.

보다 실용적인 관점에서 이더 리움은 _ 스마트 계약 _이라는 프로그램을 실행하는 오픈 소스, 글로벌 분산 컴퓨팅 인프라입니다. 실행 리소스 비용을 측정하고 제한하기 위해 _ether_라는 암호 화폐와 함께 시스템의 상태 변경을 동기화하고 저장하는 데 블록 체인을 사용합니다.

이더리움 플랫폼을 통해 개발자는 경제기능이 내장된 강력한 분산 애플리케이션을 구축할 수 있습니다. 높은 가용성, 감사 가능성, 투명성 및 중립성을 제공하는 동시에 검열을 줄이거 나 제거하고 특정 거래 상대방의 위험을 줄입니다.

[[비트코인_대조]]
===비트코인과의 차이점

((("비트코인", "이더리움"과의 비교)))((("이더리움","비트코인"과의 비교))) 많은 사람들이 암호화폐, 특히 비트코인에 대한 사전경험을 가지고 이더리움에 올 것입니다. 이더리움은 참가자를 연결하는 피어 투 피어 네트워크, 상태 업데이트 동기화를위한 비잔틴 결함 허용 합의 알고리즘&x2013 (작업 증명 블록 체인), 암호화 기본 요소 사용 등 다른 개방형 블록 체인과 많은 공통 요소를 공유합니다. 디지털 서명과 해시, 디지털 통화 (이더)로 사용됩니다.

그러나 여러면에서 이더 리움의 목적과 구성은 비트 코인을 포함하여 그 이전의 개방형 블록 체인과 현저하게 다릅니다.

((( "이더리움 (일반적인)", "목적"))) 이더리움의 목적은 꼭 디지털 통화 결제 네트워크는 아닙니다. ((( "유틸리티 통화, 이더로서"))) 디지털 통화 이더는 이더리움 운영에 필수적이며 필요하지만 이더는 세계 컴퓨터로서 이더 리움 플랫폼 사용에 대한 비용을 지불하는 _ 유틸리티 통화 _로 의도됩니다.

매우 제한된 스크립팅 언어를 사용하는 비트코인과 달리 이더리움은 임의적이고 무한한 복잡성의 코드를 실행할 수있는 _ 가상머신 _을 실행하는 범용 프로그래밍 가능 블록 체인으로 설계되었습니다. 비트코인의 스크립트 언어가 의도적으로 지출 조건에 대한 단순한 참 / 거짓 평가로 제한되는 경우, 이더리움의 언어는 _ 튜링 완료 _이며, 이는 이더리움이 범용 컴퓨터로 간단하게 기능 할 수 있음을 의미합니다.

[[블록 체인 구성 요소]]
=== 블록 체인의 구성 요소

((( "블록 체인", "구성 요소"))) ((( "이더 리움 (일반적으로)", "블록 체인 구성 요소"))) 개방형 공개 블록 체인의 구성 요소는 (보통) 다음과 같습니다.

* 표준화 된 "가십"패스를 기반으로 참가자를 연결하고 트랜잭션 및 검증 된 트랜잭션 블록을 전파하는 P2P (Peer-to-Peer) 네트워크 : [프로토콜]
* 상태 전이를 나타내는 트랜잭션 형태의 메시지
* 거래를 구성하는 요소와 유효한 상태 전환을 결정하는 일련의 합의 규칙
* 합의 규칙에 따라 트랜잭션을 처리하는 상태 머신
* 모든 확인되고 승인 된 상태 전환의 저널 역할을하는 암호화 된 보안 블록 체인
* 참여자들이 합의 규칙 시행에 협력하도록 강요하여 블록체인에 대한 통제를 분산시키는 합의 알고리즘
* 개방형 패스에서 상태 시스템을 경제적으로 보호하기위한 게임 이론적으로 건전한 인센티브 체계 (예 : 작업 증명 비용 및 블록 보상) : [환경]
* 위의 하나 이상의 오픈소스 소프트웨어 구현 ( "클라이언트")

이러한 구성 요소의 전부 또는 대부분은 일반적으로 단일 소프트웨어 클라이언트에 결합됩니다. 예를 들어, ((( "Bitcoin Core"))) ((( "bitcoind client"))) Bitcoin에서 참조 구현은 _Bitcoin Core_ 오픈 소스 프로젝트에 의해 개발되고 _bitcoind_ 클라이언트로 구현됩니다. 이더 리움에는 참조 구현이 아니라 ((( "참조 사양"))) _ 참조 사양 _, Yellow Paper (1 참조)의 시스템에 대한 수학적 설명이 있습니다. 참조 사양에 따라 구축 된 여러 클라이언트가 있습니다.

과거에 우리는 설명 된 모든 특성을 포함하는 기술 조합에 대한 약칭으로 방금 나열된 모든 구성 요소를 나타 내기 위해 "블록체인"이라는 용어를 사용했습니다. 그러나 오늘날에는 서로 다른 속성을 가진 매우 다양한 블록체인이 있습니다. 이러한 구성 요소가 허용하는 "블록체인"시스템의 중요한 새로운 특성을 식별하기 위해 _ 개방형, 공개, 글로벌, 탈 중앙화, 중립, _ 검열 방지 _와 같은 문제의 블록체인의 특성을 이해하는 데 도움이되는 한정자가 필요합니다.

모든 블록체인이 똑같이 만들어지는 것은 아닙니다. 누군가가 당신에게 무언가가 블록체인이라고 말할 때, 당신은 대답을받지 못했습니다. 오히려 "블록체인"이라는 단어를 사용할 때 의미를 명확히하기 위해 많은 질문을 시작해야합니다. 앞의 목록에있는 구성 요소에 대한 설명을 묻는 것으로 시작하여이 "블록체인"이 _open, public_ 등의 특성을 나타내는 지 물어보십시오.

[[이더리움 탄생]]
=== 이더리움의 탄생

((( "이더리움 (일반적으로)", "birth of"))) 모든 위대한 혁신은 실제 문제를 해결하며 이더리움도 예외는 아닙니다. 이더 리움은 사람들이 비트 코인 모델의 힘을 인식하고 암호 화폐 애플리케이션을 넘어서려고 할 때 구상되었습니다. 그러나 개발자는 수수께끼에 직면했습니다. 비트코인 위에 구축하거나 새로운 블록 체인을 시작해야했습니다. ((( "비트코인", "limitations of"))) 비트코인을 기반으로 구축한다는 것은 네트워크의 의도적 인 제약 내에서 생활하고 해결 방법을 찾는 것을 의미했습니다. 제한된 트랜잭션 유형, 데이터 유형 및 데이터 저장소 크기는 비트 코인에서 직접 실행할 수있는 응용 프로그램의 종류를 제한하는 것처럼 보였습니다. 그 밖의 모든 것에는 추가적인 오프 체인 레이어가 필요했고, 이는 즉시 퍼블릭 블록체인 사용의 많은 이점을 무효화했습니다. 온 체인을 유지하면서 더 많은 자유와 유연성이 필요한 프로젝트의 경우 새로운 블록체인이 유일한 옵션이었습니다. 하지만 이는 모든 인프라 요소를 부트 스트랩하고 철저한 테스트 등 많은 작업을 의미했습니다.

((( "Buterin, Vitalik"및 "이더리움의 탄생"))) 2013 년 말, 젊은 프로그래머이자 비트 코인 애호가 인 Vitalik Buterin은 비트 코인과 마스터 코인 (오버레이 프로토콜)의 기능을 더욱 확장하는 것에 대해 생각하기 시작했습니다. 초보적인 스마트 계약을 제공하기 위해 비트코인을 확장했습니다). 그해 10 월, 비탈 릭은 마스터 코인 팀에 대해보다 일반화 된 접근 방식을 제안했는데, 이는 마스터 코인의 전문 계약 언어를 대체하기 위해 유연하고 스크립팅 가능한 (튜링 완료는 아님) 계약을 허용했습니다. 마스터 코인 팀이 감명을 받았지만이 제안은 개발 로드맵에 맞추기에는 너무 급진적이었습니다.

2013 년 12 월, Vitalik은 이더리움의 개념 인 암호화 완전 범용 블록 체인을 설명하는 백서를 공유하기 시작했습니다. 수십 명의 사람들이이 초기 초안을보고 피드백을 제공하여 Vitalik이 제안을 발전시키는 데 도움을주었습니다.

이 책의 저자는 모두 백서의 초기 초안을 받고 이에 대해 논평했습니다. Andreas M. Antonopoulos는이 아이디어에 흥미를 느끼고 Vitalik에게 스마트 계약 실행에 대한 합의 규칙과 Turing-complete 언어의 의미를 적용하기위한 별도의 블록 체인 사용에 대해 많은 질문을했습니다. Andreas는 계속해서 이더리움의 발전을 큰 관심을 가지고 따라 갔지만 그의 책 _Mastering Bitcoin_을 쓰는 초기 단계에 있었고 훨씬 나중에 이더리움에 직접 참여하지 않았습니다. ((( "Wood, Dr. Gavin", "이더리움의 탄생"))) Dr. 그러나 Gavin Wood는 Vitalik에 연락하여 C ++ 프로그래밍 기술에 대한 도움을 제공 한 최초의 사람 중 한 명이었습니다. Gavin은 이더리움의 공동 설립자, 코드 서명자 및 CTO가되었습니다.

Vitalik은 http://bit.ly/2T2t6zs["Ethereum Prehistory "게시물]에서 다음과 같이 말합니다.

____
이더리움 프로토콜이 전적으로 내가 만든 시간이었습니다. 그러나 여기서부터 새로운 참가자들이 폴드에 합류하기 시작했습니다. 프로토콜 측면에서 가장 눈에 띄는 것은 Gavin Wood였습니다.

Gavin은 또한 디지털 자산을 보유하고 사전 설정된 규칙에 따라이를 범용 컴퓨팅 플랫폼으로 전송할 수있는 블록 체인 기반 계약을 통해 이더 리움을 프로그래밍 가능한 돈을 구축하기위한 플랫폼으로 보는 것에서 비전의 미묘한 변화를 크게 인정받을 수 있습니다. . 이것은 강조와 용어의 미묘한 변화로 시작되었으며, 나중에 이더 리움을 분산 기술 제품군의 한 부분으로 보았던 "웹 3"앙상블에 대한 강조가 증가하면서이 영향력은 더욱 강해졌습니다. 나머지 두 가지는 Whisper와 Swarm입니다.
____

2013 년 12 월부터 Vitalik과 Gavin은 아이디어를 개선하고 발전시켜 이더 리움이 된 프로토콜 계층을 구축했습니다.

이더리움의 창립자들은 프로그램됨으로써 다양한 애플리케이션을 지원할 수있는 특별한 목적이없는 블록 체인에 대해 생각하고있었습니다. 아이디어는 이더리움과 같은 범용 블록 체인을 사용함으로써 개발자가 피어 투 피어 네트워크, 블록 체인, 합의 알고리즘 등의 기본 메커니즘을 구현하지 않고도 특정 애플리케이션을 프로그래밍 할 수 있다는 것입니다. 이더리움 플랫폼은 추상화하도록 설계되었습니다. 이러한 세부 사항을 확인하고 분산 형 블록 체인 애플리케이션을위한 결정적이고 안전한 프로그래밍 환경을 제공합니다.

Satoshi와 마찬가지로 Vitalik과 Gavin은 단지 새로운 기술을 발명 한 것이 아닙니다. 그들은 새로운 발명품과 기존 기술을 새로운 방식으로 결합하고 그들의 아이디어를 세상에 증명하기 위해 프로토 타입 코드를 전달했습니다.

창립자는 수년간 일하면서 비전을 구축하고 개선했습니다. 그리고 2015 년 7 월 30 일에 첫 번째 이더리움 블록이 채굴되었습니다. 세계의 컴퓨터가 세상에 서비스를 제공하기 시작했습니다.

[메모]
====
Vitalik Buterin의 기사 "A Prehistory of Ethereum"은 2017 년 9 월에 발행되었으며 이더리움의 초기 순간에 대한 매혹적인 1 인칭 시점을 제공합니다.

당신은 그것을 읽을 수 있습니다
https://vitalik.ca/general/2017/09/14/prehistory.html[].
====

[[개발 _ 단계]]
=== 이더리움의 개발의 4단계

((( "이더리움 (일반적으로)", "개발의 4 단계"))) 이더리움의 개발은 각 단계에서 주요 변경 사항이 발생하는 4 단계에 걸쳐 계획되었습니다. ((( "하드포크", seealso = "DAO; 기타 특정 하드 포크, 예 : 스퓨리어스 드래곤"))) 단계에는 하위 버전과 호환되지 않는 방식으로 기능을 변경하는 "하드포크"라고하는 하위 릴리스가 포함될 수 있습니다. .

네 가지 주요 개발 단계는 코드 명 _Frontier_, _Homestead_, _Metropolis_ 및 _Serenity_입니다. 현재까지 발생한 (또는 계획된) 중간 하드 포크는 코드 명 _Ice Age_, _DAO_, _Tangerine Whistle_, _Spurious Dragon_, _Byzantium_ 및 _Constantinople_입니다. 개발 단계와 중간 하드 포크 모두 다음 타임 라인에 표시되며 블록 번호로 "날짜"가 지정됩니다.


블록 # 0 :: ((( "프론티어"))) __ Frontier __ & # x2014; 2015 년 7 월 30 일부터 2016 년 3 월까지 지속되는 이더 리움의 초기 단계.

블록 # 200,000 :: ((( "아이스 에이지"))) __ 아이스 에이지 __ & # x2014; 준비되었을 때 PoS 로의 전환을 유도하기 위해 지수 난이도 증가를 도입하는 하드 포크.

Block # 1,150,000 :: ((( "Homestead"))) __ Homestead __ & # x2014; 2016 년 3 월에 시작된 이더 리움의 두 번째 단계.

Block # 1,192,000 :: ((( "DAO (Decentralized Autonomous Organization)"))) __ DAO __ & # x2014; 해킹 된 DAO 계약의 피해자를 보상하고 이더리움과 이더리움 클래식을 두 개의 경쟁 시스템으로 분할 한 하드 포크.

Block # 2,463,000 :: ((( "Tangerine Whistle"))) __ Tangerine Whistle __ & # x2014; 특정 I / O가 많은 작업에 대한 가스 계산을 변경하고 서비스 거부에서 누적 된 상태를 지우는 하드 포크 ( 이러한 작업의 낮은 가스 비용을 악용 한 DoS) 공격.

Block # 2,675,000 :: ((( "Spurious Dragon"))) __ Spurious Dragon __ & # x2014; 더 많은 DoS 공격벡터를 처리하기위한 하드포크 및 또 다른상태 제거. 또한 재공격 보호 메커니즘입니다.


블록 # 4,370,000 :: ((( "Metropolis"))) ((( "Byzantium fork"))) __ Metropolis Byzantium __ & # x2014; Metropolis는 2017 년 10 월에 출시 된이 책을 쓰는 시점에 현재 이더리움의 세 번째 단계입니다. 비잔티움은 메트로폴리스를 위해 계획된 두 개의 하드포크 중 첫 번째입니다.


비잔티움 이후 메트로폴리스를 위해 계획된 하드 포크가 하나 더 있습니다 : ((( "Constantinople fork"))) ((( "Serenity"))) Constantinople. Metropolis는 이더리움 배포의 마지막 단계 인 코드 명 Serenity가 이어질 것입니다.


[[블록체인의 일반목적]]
=== 이더 리움 : 범용 블록 체인

((( "비트코인", "비트코인 블록체인과 비교 한 이더리움 블록 체인"))) ((( "이더리움 (일반적으로)", "범용 블록체인으로서"))) 원래 블록체인, 즉 비트코인의 블록체인은 비트코인 단위 및 소유권. ((( "분산 상태 머신, 이더리움"))) 비트코인을 분산 합의 _ 상태 머신 _으로 생각할 수 있습니다. 여기서 트랜잭션은 글로벌 _ 상태 전환 _을 유발하여 코인의 소유권을 변경합니다. 상태 전환은 합의 규칙에 의해 제한되어 여러 블록이 채굴 된 후 모든 참여자가 시스템의 공통 (합의) 상태로 (결국) 수렴 할 수 있습니다.

이더리움은 또한 분산 상태 머신입니다. 그러나 통화 소유권 상태 만 추적하는 대신 ((( "key-value tuple"))) Ethereum은 범용 데이터 저장소, 즉 _key로 표현 가능한 모든 데이터를 저장할 수있는 저장소의 상태 전환을 추적합니다. tuple_ 값. 키-값 데이터 저장소는 각각 일부 키가 참조하는 임의의 값을 보유합니다. 예를 들어, "Book Title"키가 참조하는 "Mastering Ethereum"값. 어떤면에서 이것은 대부분의 범용 컴퓨터에서 사용되는 _Random Access Memory_ (RAM)의 데이터 저장 모델과 동일한 용도로 사용됩니다. 이더 리움은 코드와 데이터를 모두 저장하는 메모리를 가지고 있으며 이더 리움 블록 체인을 사용하여이 메모리가 시간에 따라 어떻게 변하는 지 추적합니다. 범용 저장 프로그램 컴퓨터와 마찬가지로 이더리움은 상태 머신에 코드를로드하고 해당 코드를 _run_하여 결과 상태 변경을 블록 체인에 저장할 수 있습니다. 대부분의 범용 컴퓨터와의 중요한 차이점 중 두 가지는 이더 리움 상태 변경이 합의 규칙에 의해 관리되고 상태가 전 세계적으로 배포된다는 것입니다. 이더리움은 "임의의 상태를 추적하고 상태 머신을 프로그래밍하여 합의하에 작동하는 전세계 컴퓨터를 만들 수 있다면 어떨까요?"라는 질문에 답합니다.

[[이더리움 _ 구성요소]]
=== 이더리움의 구성요소

((( "blockchain", "components of"))) ((( "이더리움 (일반적으로)", "blockchain components"))) 이더리움에서 <>에 설명 된 블록체인 시스템의 구성 요소는보다 구체적으로 다음과 같습니다.


P2P 네트워크 :: 이더리움은 TCP 포트 30303에서 주소를 지정할 수있는 _이더리움 메인 네트워크 _에서 실행되며 _ÐΞVp2p_라는 프로토콜을 실행합니다.

합의 규칙 :: 이더리움의 합의 규칙은 참조 사양 인 Yellow Paper에 정의되어 있습니다 (<> 참조).

거래 :: 이더리움 거래는 발신자, 수신자, 가치 및 데이터 페이로드를 포함하는 네트워크 메시지입니다.

[role = "페이지 나누기 전"]
상태 머신 :: 이더리움 상태 전환은 _bytecode_ (머신 언어 명령어)를 실행하는 스택 기반 가상 머신 인 _Ethereum Virtual Machine_ (EVM)에 의해 처리됩니다. "스마트 계약"이라고하는 EVM 프로그램은 고급 언어 (예 : Solidity)로 작성되고 EVM에서 실행하기 위해 바이트 코드로 컴파일됩니다.

데이터 구조 :: 이더리움의 상태는 각 노드에 _database_ (일반적으로 Google의 LevelDB)로 로컬에 저장되며, _Merkle Patricia Tree_라고하는 직렬화 된 해시 데이터 구조에 트랜잭션 및 시스템 상태를 포함합니다.

합의 알고리즘 :: 이더 리움은 비트 코인의 합의 모델 인 Nakamoto Consensus를 사용합니다.이 모델은 순차적 인 단일 서명 블록을 사용하며 PoW에 의해 중요성이 가중되어 가장 긴 체인과 현재 상태를 결정합니다. 그러나 가까운 장래에 코드 명 _Casper_ 인 PoS 가중치 투표 시스템으로 이동할 계획이 있습니다.

경제적 보안 :: 이더 리움은 현재 _Ethash_라는 PoW 알고리즘을 사용하지만, 이는 향후 언젠가 PoS로 이동하면서 결국 삭제 될 것입니다.

클라이언트 :: 이더 리움에는 클라이언트 소프트웨어의 상호 운용 가능한 여러 구현이 있으며, 그중 가장 두드러진 것은 _Go-Ethereum _ (_ Geth_) 및 _Parity_입니다.

[[참조]]
==== 추가 읽기

다음 참조는 여기에 언급 된 기술에 대한 추가 정보를 제공합니다.

* 이더리움 옐로우 페이퍼 :
https://ethereum.github.io/yellowpaper/paper.pdf

* The Beige Paper, 덜 형식적인 언어로 더 많은 청중을 위해 Yellow Paper를 재 작성 :
https://github.com/chronaeon/beigepaper

* ÐΞVp2p 네트워크 프로토콜 :
http://bit.ly/2quAlTE

* 이더리움 가상머신 리소스 목록 :
http://bit.ly/2PmtjiS

* LevelDB 데이터베이스 (블 체인의 로컬 사본을 저장하는 데 가장 자주 사용됨) :
https://github.com/google/leveldb

* 머클 패트리샤 나무 :
https://github.com/ethereum/wiki/wiki/Patricia-Tree

* Ethash PoW 알고리즘 :
https://github.com/ethereum/wiki/wiki/Ethash

* Casper PoS v1 구현 가이드 :
http://bit.ly/2DyPr3l

* Go-Ethereum (Geth) 클라이언트 :
https://geth.ethereum.org/

* 패리티 이더리움 클라이언트 :
https://parity.io/

[[튜링_완전성]]
=== 이더 리움과 튜링 완전성

((( "이더리움(일반적으로)", "튜링 완전성 및"))) ((( "튜링 완전성", "이더리움 그리고"))) 이러리움에 대해 읽기 시작하자마자 "완전한 튜링." 이더리움은 비트코인과 달리 튜링이 완성되었다고 말합니다. 그게 정확히 무슨 뜻입니까?

((( "Turing, Alan")))이 용어는 컴퓨터 과학의 아버지로 간주되는 영어 수학자 Alan Turing을 나타냅니다. 1936 년에 그는 순차 메모리 (무한 길이의 종이 테이프를 닮은)에서 기호를 읽고 써서 기호를 조작하는 상태 기계로 구성된 컴퓨터의 수학적 모델을 만들었습니다. 이 구조를 통해 Turing은 모든 문제를 해결할 수 있는지 여부를 의미하는 _ 유니버설 컴퓨팅 가능성 _에 대한 (부정적인) 질문에 답할 수있는 수학적 토대를 제공했습니다. 그는 계산할 수없는 문제가 있음을 증명했습니다. ((( "halting problem"))) 특히 그는 _halting problem_ (임의의 프로그램과 입력이 주어 졌을 때 프로그램이 결국 실행을 중지할지 여부를 결정하는 것이 가능한지 여부)이 해결할 수 없음을 증명했습니다.

((( "유니버설 튜링 머신 (UTM)"))) ((( "UTM (유니버설 튜링 머신)"))) Alan Turing은 튜링 머신을 시뮬레이션하는 데 사용할 수있는 경우 시스템을 _ 튜링 완료 _로 정의했습니다. 이러한 시스템을 _Universal Turing machine_ (UTM)이라고합니다.

이더리움 가상 머신이라는 상태 머신에서 저장된 프로그램을 실행하는 이더리움의 기능은 데이터를 읽고 메모리에 쓰는 동안 Turing-complete 시스템이므로 UTM이됩니다. 이더 리움은 유한 메모리의 한계를 고려할 때 모든 튜링 머신에서 계산할 수있는 모든 알고리즘을 계산할 수 있습니다.

이더 리움의 획기적인 혁신은 저장된 프로그램 컴퓨터의 범용 컴퓨팅 아키텍처를 분산 형 블록 체인과 결합하여 분산 된 단일 상태 (단일) 세계 컴퓨터를 만드는 것입니다. 이더 리움 프로그램은 "모든 곳에서"실행되지만 통과 규칙에 의해 보호되는 공통 상태를 생성합니다.

[[튜링_완전성_기능]]
==== "기능"으로서의 튜링 완전성

((( "튜링 완성도", "기능으로"))) 이더리움이 튜링이 완성되었다는 말을 들으면 이것이 튜링이 불완전한 시스템에 부족한 _기능_라는 결론에 도달 할 수 있습니다. 오히려 그 반대입니다. 튜링 완전성은 달성하기 매우 쉽습니다. 사실, http://bit.ly/2ABft33[the simplest Turing-complete 상태 머신]은 4 개의 상태를 가지며 6 개의 심볼을 사용하며, 22 개의 명령어 길이에 불과한 상태 정의를 사용합니다. 실제로 때때로 시스템이 "우연히 튜링이 완료"된 것으로 확인됩니다. 이러한 시스템에 대한 재미있는 참조는 아래에서 찾을 수 있습니다.'http://bit.ly/2Og1VgX'

그러나 튜링 완전성은 특히 공개 블록 체인과 같은 개방형 액세스 시스템에서 매우 위험합니다. 예를 들어, 최신 프린터는 튜링이 완료되었으며 인쇄 할 파일을 제공하여 고정 된 상태로 보낼 수 있습니다. 이더리움이 튜링 완전하다는 사실은 모든 복잡한 프로그램이 이더리움에 의해 계산 될 수 있음을 의미합니다. 그러나 이러한 유연성은 몇 가지 까다로운 보안 및 리소스 관리 문제를 야기합니다. 응답하지 않는 프린터를 껐다가 다시 켤 수 있습니다. 퍼블릭 블록 체인으로는 불가능합니다.

[[튜링_완전성_의미]]
==== 튜링 완전성의 의미

((( "튜링 완성도", "의미"))) 튜링은 프로그램을 컴퓨터에서 시뮬레이션하여 종료할지 여부를 예측할 수 없음을 입증했습니다. 간단히 말해서 프로그램을 실행하지 않고서는 프로그램의 경로를 예측할 수 없습니다. ((( "무한 루프"))) 튜링 완료 시스템은 종료되지 않는 프로그램을 설명하는 데 사용되는 용어 인 "무한루프"에서 실행될 수 있습니다. 끝나지 않는 루프를 실행하는 프로그램을 만드는 것은 간단합니다. 그러나 시작 조건과 코드 간의 복잡한 상호 작용으로 인해 의도하지 않은 끝없는 루프가 경고없이 발생할 수 있습니다. 이더 리움에서 이것은 도전을 제기합니다. 모든 참여 노드 (클라이언트)는 모든 트랜잭션을 검증해야하며 호출하는 스마트 계약을 실행해야합니다. 그러나 튜링이 증명했듯이 이더리움은 실제로 실행하지 않고는 스마트 계약이 종료되는지 또는 얼마나 오래 실행 될지 예측할 수 없습니다 (영원히 실행될 수 있음). 실수로든 고의로 든 스마트 계약은 노드가 검증을 시도 할 때 영원히 실행되도록 생성 될 수 있습니다. 이것은 사실상 DoS 공격입니다. 물론, 검증하는 데 1 밀리 초가 걸리는 프로그램과 영원히 실행되는 프로그램 사이에는 단순히 리소스를 낭비하는 엄청나고 리소스를 많이 차지하고 메모리를 많이 차지하는 CPU 과열 프로그램이 무한대로 존재합니다. 세계 컴퓨터에서 자원을 남용하는 프로그램은 세계의 자원을 남용하게됩니다. 이더리움은 리소스 사용을 미리 예측할 수없는 경우 스마트 계약에서 사용하는 리소스를 어떻게 제한합니까?

((( "EVM (이더리움 가상 머신)", "gas and"))) ((( "gas", "Turing 완전성에 대한 반대")))이 문제에 답하기 위해 이더리움은 _gas_라는 계량 메커니즘을 도입합니다. EVM이 스마트 계약을 실행함에 따라 모든 명령 (계산, 데이터 액세스 등)을 신중하게 고려합니다. 각 명령에는 가스 단위로 미리 정해진 비용이 있습니다. 트랜잭션이 스마트 계약 실행을 트리거 할 때 스마트 계약을 실행하여 소비 할 수있는 최대 한도를 설정하는 가스량을 포함해야합니다. EVM은 계산에 사용되는 가스의 양이 트랜잭션에서 사용 가능한 가스를 초과하면 실행을 종료합니다. 가스는 이더리움이 모든 프로그램이 소비 할 수있는 리소스를 제한하면서 Turing-complete 계산을 허용하는 데 사용하는 메커니즘입니다.

다음 질문은 '이더리움 세계 컴퓨터에서 계산 비용을 지불하기 위해 가스를 어떻게 얻는가?'입니다. 어떤 교환에서도 가스를 찾을 수 없습니다. ((( "이더 (일반적으로)", "gas and"))) 거래의 일부로 만 구매할 수 있으며 이더로만 구매할 수 있습니다. 이더는 거래와 함께 전송되어야하며 허용 가능한 가스 가격과 함께 가스 구매를 위해 명시 적으로 할당되어야합니다. 펌프에서와 마찬가지로 가스 가격은 고정되어 있지 않습니다. 거래를 위해 가스를 구매하고 계산이 실행되고 사용하지 않은 가스는 거래 발신자에게 환불됩니다.

[[DApp]]
=== 범용 블록 체인에서 분산 애플리케이션 (DApp)으로

((( "DApps (분산 애플리케이션)", "플랫폼으로서의 이더리움"))) ((( "이더리움 (일반적으로)", "DApps and"))) 이더리움은 다양한 용도로 프로그래밍 할 수 있습니다. 그러나 매우 빠르게 이더 리움의 비전은 DApp 프로그래밍을위한 플랫폼으로 확장되었습니다. DApp은 스마트 계약보다 더 넓은 관점을 나타냅니다. DApp은 최소한 스마트 계약이자 웹 사용자 인터페이스입니다. 더 넓게 보면 DApp은 개방적이고 분산 된 P2P 인프라 서비스 위에 구축 된 웹 애플리케이션입니다.

DApp은 최소한 다음으로 구성됩니다.

-블록체인의 스마트 계약
웹 프런트엔드 사용자 인터페이스

또한 많은 DApp에는 다음과 같은 다른 분산 구성 요소가 포함됩니다.

-분산 형 (P2P) 스토리지 프로토콜 및 플랫폼
-분산 형 (P2P) 메시징 프로토콜 및 플랫폼

[TIP]
====
철자가 _ & # 208; Apps_ 인 DApp을 볼 수 있습니다. & # 208; character는 이더리움을 암시하는 "ETH"라는 라틴 문자입니다. 이 문자를 표시하려면 유니 코드 코드 포인트 + 0xD0 +를 사용하거나 필요한 경우 HTML 문자 엔티티 + eth + (또는 십진 엔티티 + # 208 +)를 사용하십시오.
====

[[evolving_WWW]]
=== 인터넷의 제 3 시대

((( "DApps (분산 형 애플리케이션)", "web3 및"))) ((( "이더리움 (일반적으로)", "web3 and"))) ((( "web3"))) 2004 년에 "웹 2.0 "은 사용자 제작 콘텐츠, 반응 형 인터페이스 및 상호 작용을 향한 웹의 진화를 설명하면서 두각을 나타 냈습니다. 웹 2.0은 기술 사양이 아니라 웹 패스의 새로운 초점을 설명하는 용어입니다.

DApps의 개념은 웹 애플리케이션의 모든 측면에 피어 투 피어 프로토콜을 사용한 분산화를 도입하여 월드 와이드 웹을 다음 자연적인 진화 단계로 가져가는 것을 의미합니다. 이러한 진화를 설명하는 데 사용되는 용어는 웹의 세 번째 "버전"을 의미하는 _web3_입니다. ((( "Wood, Dr. Gavin", "and web3"))) Dr. Gavin Wood가 처음 제안한 web3는 중앙에서 소유하고 관리하는 애플리케이션에서 분산 프로토콜을 기반으로 구축 된 애플리케이션에 이르기까지 웹 애플리케이션에 대한 새로운 비전과 초점을 나타냅니다. .

이후 장에서는 브라우저에서 실행되는 JavaScript 애플리케이션을 이더리움 블록 체인과 연결하는 이더리움 web3.js JavaScript 라이브러리를 살펴 보겠습니다. web3.js 라이브러리에는 _Swarm_이라는 P2P 스토리지 네트워크에 대한 인터페이스와 _Whisper_라는 P2P 메시징 서비스도 포함되어 있습니다. 웹 브라우저에서 실행되는 JavaScript 라이브러리에 포함 된이 세 가지 구성 요소를 통해 개발자는 web3 DApp을 빌드 할 수있는 전체 애플리케이션 개발 제품군을 갖게됩니다.

[[개발 _ 문화]]
=== 이더리움의 개발문화

((( "개발문화, 이더리움"))) ((( "이더리움 (일반적으로)", "개발 문화"))) 지금까지 이더리움의 목표와 기술이 이전의 다른 블록 체인과 어떻게 다른지에 대해 이야기했습니다. , 비트코인처럼. 이더리움은 또한 매우 다른 개발 문화를 가지고 있습니다.

(( "비트코인", "개발문화"))) 비트코인에서 개발은 보수적 인 원칙에 따라 진행됩니다. 기존 시스템이 중단되지 않도록 모든 변경 사항을주의 깊게 연구합니다. 대부분의 경우 변경 사항은 이전 버전과 호환되는 경우에만 구현됩니다. 기존 클라이언트는 옵트 인 할 수 있지만 업그레이드하지 않기로 결정하면 계속 작동합니다.

((( "역호환성, 이더리움 vs. 비트코인"))) 이더리움에서 비교하면 커뮤니티의 개발문화는 과거보다는 미래에 초점을 맞추고 있습니다. (전적으로 진지하지 않은) 만트라는 "빨리 움직이고 물건을 부수는 것"입니다. 변경이 필요한 경우 이전 가정을 무효화하거나 호환성이 깨지거나 클라이언트가 업데이트하도록 강요하는 경우에도 변경이 구현됩니다. 이더리움의 개발문화는 이전버전과의 호환성을 희생하더라도 빠른 혁신, 빠른 진화 및 미래 지향적 개선을 배포하려는 의지가 특징입니다.

이것이 개발자에게 의미하는 바는 일부 기본 가정이 변경됨에 따라 유연성을 유지하고 인프라를 재 구축 할 준비가되어 있어야한다는 것입니다. 이더리움에서 개발자가 직면한 큰 과제 중 하나는 변경 불가능한 시스템에 코드를 배포하는 것과 여전히 진화하는 개발 플랫폼 사이의 본질적인 모순입니다. 스마트 계약을 단순히 "업그레이드"할 수는 없습니다. 새 항목을 배포하고 사용자, 앱 및 자금을 마이그레이션하고 다시 시작할 준비가되어 있어야합니다.

아이러니하게도 이것은 또한 더 많은 자율성과 덜 중앙화 된 제어로 시스템을 구축하려는 목표가 아직 완전히 실현되지 않았 음을 의미합니다. 자율성과 탈 중앙화는 향후 몇 년 동안 이더 리움에서 얻을 수있는 것보다 플랫폼에서 더 많은 안정성을 요구합니다. 플랫폼을 "진화"하려면 스마트 계약을 폐기하고 다시 시작할 준비가되어 있어야합니다. 즉, 해당 계약에 대한 어느 정도의 제어 권한을 유지해야합니다.

그러나 긍정적 인 측면에서 이더리움은 매우 빠르게 발전하고 있습니다. 원자력 발전소 뒷편에 자전거 창고를 짓는 방법과 같은 사소한 세부 사항에 대해 논쟁을 벌이면서 개발을 지연시키는 표현 인 "자전거 흘리기"의 기회는 거의 없습니다. 자전거를 흘리기 시작하면주의가 산만 해지는 동안 나머지 개발 팀이 자율 호버크라프트를 위해 계획을 변경하고 자전거를 버렸다는 사실을 갑자기 발견 할 수 있습니다.

결국 이더리움 플랫폼의 개발 속도가 느려지고 인터페이스가 수정 될 것입니다. 하지만 그동안 혁신이 원동력입니다. 아무도 당신을 위해 속도를 늦추지 않기 때문에 계속하는 것이 좋습니다.

[[왜 배우는가]]
== 왜 이더리움을 배우는가?

((( "블록체인", "개발자의 블록체인으로서의 이더리움"))) ((( "이더리움 (일반적으로)", "학습이유"))) 블록체인은 여러 가지를 결합하기 때문에 매우 가파른 학습 곡선을 가지고 있습니다. 프로그래밍, 정보 보안, 암호화, 경제학, 분산 시스템, 피어-투-피어 네트워크 등의 분야를 하나의 도메인으로 만듭니다. 이더리움은이 학습 곡선을 훨씬 덜 가파르게 만들어 빠르게 시작할 수 있습니다. 그러나 믿을 수 없을 정도로 단순한 환경의 표면 바로 아래에는 훨씬 더 많은 것이 있습니다. 배우고 더 깊게 살펴보기 시작하면 항상 또 다른 복잡성과 경이로움이 있습니다.

이더리움은 블록 체인에 대해 배우기위한 훌륭한 플랫폼이며 다른 어떤 블록 체인 플랫폼보다 빠르게 대규모 개발자 커뮤니티를 구축하고 있습니다. 무엇보다 이더 리움은 개발자를 위해 개발자가 구축한 _ 개발자의 블록체인 _입니다. JavaScript 애플리케이션에 익숙한 개발자는 이더 리움에 들어가 작업 코드를 매우 빠르게 생성 할 수 있습니다. 이더리움의 처음 몇 년 동안, 단 5 줄의 코드로 토큰을 생성 할 수 있다고 발표하는 티셔츠를 보는 것이 일반적이었습니다. 물론 이것은 양날의 검입니다. 코드를 작성하는 것은 쉽지만 _good_ 및 _secure_ 코드를 작성하는 것은 매우 어렵습니다.

[[목표를-가르치기]]
===이 책에서 배울 수있는 것

이 책은 이더리움에 대해 자세히 살펴보고 모든 구성 요소를 검토합니다. 간단한 트랜잭션으로 시작하여 작동 방식을 분석하고, 간단한 계약을 작성하고, 개선하고, 이더리움 시스템을 통한 여정을 따릅니다.

Ethereum을 사용하는 방법과 작동 원리를 배우게 될뿐만 아니라 그것이 왜 그렇게 설계되었는지도 배울 것입니다. 각 조각이 어떻게 작동하는지, 어떻게 서로 잘 맞으며 그 이유를 이해할 수 있습니다. (((range = "endofrange", startref = "ix_01what-is-asciidoc0"))) ((( "account", " contract ", see ="스마트 계약 "))) ((("비대칭 암호화 ", see ="공개 키 암호화 "))) ((("BIPs ", see ="비트 코인 개선 제안 "))) ((( "burn", see = "ether burn"))) ((( "cryptography", "asymmetric", see = "공개 키 암호화"))) ((( "decentralized applications", see = "DApps"))) ((( "Decentralized Autonomous Organization", see = "DAO"))) ((( "default function", see = "fallback function"))) ((( "deterministic (seeded) wallets", "hierarchical", see = "계층 적 결정 론적 지갑"))) ((( "DoS 공격", "서비스 거부 공격"))) ((( "ECDSA", see = "Elliptic Curve Digital Signature Algorithm"))) ((( "ETC", see = "Ethereum Classic"))) ((( "Ethereum (일반)", "clients", see = "clients, Ethereum"))) ((( "Ethereum 개선 제안", see = "EIP 항목 "))) ((("이더 리움 이름 서비스 ", see ="ENS "))) ((("이더 리움 가상 머신 ", 참조 = "EVM"))) ((( "외부 소유 계정", see = "EOA"))) ((( "fees", see = "gas"))) ((( "ICOs", see = "Initial Coin 오퍼링 "))) ((("이더 리움 토큰 마스터 링 ", see ="METoken "))) ((("MEW ", see ="MyEtherWallet "))) ((("names / naming ", see ="ENS (이더 리움 이름 서비스) "))) ((("NFTs ", see ="대체 불가능한 토큰 "))) ((("PoS ", see ="PoS "))) ((("PoW ", 참조 = "작업 증명"))) ((( "PoWHC", "위크 핸즈 코인 증명"))) (( "원격 프로 시저 호출 (RPC) 명령", 참조 = "JSON-RPC API") )) ((( "RPC (원격 프로 시저 호출) 명령", 참조 = "JSON-RPC API"))) ((( "보안 해시 알고리즘", 참조 = "SHA 항목"))) ((( "시드 된 지갑 ", see ="결정적 지갑 "))) ((("스마트 계약 ","Vyper and ", see ="Vyper "))) ((("스마트 폰 ", see ="모바일 (스마트 폰) 지갑 ")) ) ((( "storage", see = "data storage"))) ((( "SUICIDE", see = "SELFDESTRUCT opcode"))) ((( "synchronization", see = "빠른 동기화"))) ( (( "synchronization", see = "첫 번째 동기화"))) ((( "거래 수수료", see = "gas"))) ((( "wallets", "HD", see = "계층 적 결정적 지갑 "))) ((("지갑 ","메타 마스크 ", 참조 ="메타 마스크 ")))