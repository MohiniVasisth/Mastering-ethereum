[[intro_chapter]]
== Podstawy Ethereum

(((("Ethereum (ogólnie)”,"podstawy”, id="ix_02intro-asciidoc0", range="startofrange")))IW tym rozdziale zaczniemy odkrywać Ethereum, ucząc się, jak korzystać z portfeli, jak tworzyć transakcje, a także jak przeprowadzić podstawową inteligentną umowę.

[[ether_units]]
=== Jednostki Walutowe Eteru

((("jednostki walutowe”)))((("Ethereum (ogólnie)”,"jednostki walutowe”))) Jednostka walutowa Ethereum nazywa się _ether_, oznaczona również jako „ETH” lub symbolami &#926; (od greckiej litery „Xi”, która wygląda jak stylizowana wielka litera E) lub, rzadziej, &#9830;: na przykład 1 eter lub 1 ETH lub &#926;1 lub &#9830;1.

[TIP]
====
Użyj znaku Unicode +U+039E+ dla &#926; i +U+2666+ dla &#9830;.
====

Eter jest podzielony na mniejsze jednostki, aż do najmniejszej możliwej jednostki, która nazywa się _wei_. Jeden eter to 1 kwintillion wei (1 * 10^18^ lub 1,000,000,000,000,000,000,000). Możesz słyszeć, jak ludzie nazywają walutę „Ethereum”, ale jest to częsty błąd początkującego. Ethereum to system, eter to waluta.

Wartość eteru jest zawsze reprezentowana wewnętrznie w Ethereum jako wartość nieoznaczonej liczby całkowitej denominowanej w wei. Podczas transakcji 1 eterem transakcja koduje 1000000000000000000 wei jako wartość.

Różne nominały Etheru mają zarówno naukową nazwę, używając Międzynarodowego Systemu Jednostek (_SI_), jak i potoczną nazwę, która składa hołd wielu wielkim umysłom komputerów i kryptografii.

<<ether_denominations>>pokazuje różne jednostki, ich potoczne (pospolite) nazwy i ich nazwy SI. Zgodnie z wewnętrzną reprezentacją wartości, tabela pokazuje wszystkie nominały wei (pierwszy rząd), a eter pokazany jako 10^18^ wei w 7 rzędzie.

[[ether_denominations]]
.Nominały Eteru i nazwy jednostek
[options="header"]
|===
| Wartość (we wei) | Wykładnik | Nazwa zwyczajowa | Nazwa SI
| 1 | 1 | wei | Wei
| 1000 | 10 ^ 3 ^ | Babbage | Kilowei lub femtoether
| 1,000,000 | 10^6^ | Lovelace | Megawei lub picoether
| 1,000,000,000 | 10^9^ | Shannon | Gigawei lub nanoether
| 1,000,000,000,000 | 10^12^ | Szabo | Microether lub micro
| 1,000,000,000,000,000 | 10^15^ | Finney | Milliether lub milli
| _1,000,000,000,000,000,000_ | _10^18^_ | _Ether_ | _Ether_
| 1,000,000,000,000,000,000,000 | 10^21^ | Grand | Kiloether
| 1,000,000,000,000,000,000,000,000 | 10^24^ | | Megaether
|===

[[choosing_eth_wallet]]
=== Wybór Portfela Ethereum

((("Ethereum (ogólnie)”,"wybór portfela”)))((("portfele”,"wybór”))))((("portfele”,"zdefiniowane”))) Określenie „portfel" może oznaczać wiele rzeczy, chociaż wszystkie są powiązane i na co dzień sprowadzają się do prawie tego samego. Użyjemy terminu „portfel”, aby oznaczać aplikację, która pomaga zarządzać kontem Ethereum. Krótko mówiąc, portfel Ethereum jest Twoją bramą do systemu Ethereum. Przechowuje klucze i może tworzyć i nadawać transakcje w Twoim imieniu. Wybór portfela Ethereum może być trudny, ponieważ istnieje wiele różnych opcji o różnych funkcjach i wzorach. Niektóre są bardziej odpowiednie dla początkujących, a niektóre są bardziej odpowiednie dla ekspertów. Sama platforma Ethereum jest wciąż ulepszana, a „najlepsze” portfele często dostosowują się do zmian związanych z aktualizacjami platformy.

Ale nie martw się! Jeśli wybierzesz portfel i nie podoba ci się jego działanie&#x2014;, lub jeśli na początku Ci się spodoba, ale później zechcesz wypróbować coś innego&#x2014;, możesz łatwo zmienić portfele. Wystarczy, że wykonasz transakcję, która wyśle ​​środki ze starego portfela do nowego portfela lub wyeksportujesz klucze prywatne i zaimportujesz je do nowego.

Wybraliśmy trzy różne typy portfeli do wykorzystania jako przykłady w całej książce: portfel mobilny, portfel biurkowy i portfel internetowy. Wybraliśmy te trzy portfele, ponieważ reprezentują szeroki zakres złożoności i funkcji. Wybór tych portfeli nie stanowi jednak potwierdzenia ich jakości ani bezpieczeństwa. Są po prostu dobrym miejscem do rozpoczęcia pokazów i testów.

((("klucze prywatne”,"portfele i”))) Pamiętaj, że aby aplikacja portfela działała, musi mieć dostęp do twoich kluczy prywatnych, dlatego ważne jest, aby pobierać i używać aplikacji portfela tylko z zaufanych źródeł. Na szczęście, ogólnie rzecz biorąc, im bardziej popularna jest aplikacja portfela, tym bardziej prawdopodobne, że będzie ona wiarygodna. Niemniej jednak dobrą praktyką jest unikanie „wkładania wszystkich jajek do jednego koszyka” i rozłożenie kont Ethereum na kilka portfeli.

Oto kilka dobrych portfeli początkowych:

MetaMask :: ((("MetaMask”))) MetaMask to portfel rozszerzeń przeglądarki działający w przeglądarce (Chrome, Firefox, Opera lub Brave Browser). Jest łatwy w użyciu i wygodny do testowania, ponieważ może łączyć się z różnymi węzłami Ethereum i testować łańcuchy bloków. MetaMask to portfel internetowy.

Jaxx:: ((("Jaxx”)))((("portfele”,"Jaxx”)))Jaxx to wieloplatformowy i wielowalutowy portfel, który działa na różnych systemach operacyjnych, w tym Android, iOS, Windows, macOS, i Linux. Jest to często dobry wybór dla nowych użytkowników, ponieważ został zaprojektowany z myślą o prostocie i łatwości użytkowania. Jaxx to portfel mobilny lub stacjonarny, w zależności od miejsca instalacji.

MyEtherWallet (MEW):: (((„Ethereum Classic (ETC)”,"Emerald Wallet i”)))((("MyEtherWallet (MEW)”))) ((("portfele”,"Emerald Wallet”)))((("portfele”,"MyEtherWallet”))) MyEtherWallet to portfel internetowy działający w dowolnej przeglądarce. Ma wiele wyrafinowanych funkcji, które zbadamy w wielu naszych przykładach. MyEtherWallet to portfel internetowy.

Emerald Wallet :: ((("Emerald Wallet”)))Emerald Wallet został zaprojektowany do współpracy z blockchainem Ethereum Classic, ale jest kompatybilny z innymi blockchainami opartymi na Ethereum. Jest to aplikacja komputerowa typu open source i działa w systemach Windows, macOS i Linux. Emerald Wallet może uruchomić pełny węzeł lub połączyć się z publicznym zdalnym węzłem, pracując w trybie „lekkim”. Posiada również narzędzie towarzyszące do wykonywania wszystkich operacji z wiersza poleceń.

Zaczniemy od zainstalowania MetaMask na pulpicie&#x2014;, ale najpierw omówimy krótko sterowanie i zarządzanie kluczami.

[[control_responsibility]]
=== Kontrola i Odpowiedzialność

(((„Ethereum (ogólnie)”,"kontrola i odpowiedzialność”, id="ix_02intro-asciidoc1”, range ="startofrange”)))Otwarte łańcuchy bloków, takie jak Ethereum, są ważne, ponieważ działają jako system _zdecentralizowany_. Oznacza to wiele rzeczy, ale jednym z kluczowych aspektów jest to, że każdy użytkownik Ethereum może&#x2014; i powinien&#x2014; kontrolować własne klucze prywatne, które kontrolują dostęp do funduszy i inteligentnych umów. Czasami nazywamy połączenie dostępu do funduszy i inteligentnych umów „kontem” lub „portfelem”. Warunki te mogą stać się dość skomplikowane pod względem funkcjonalności, więc zajmiemy się tym bardziej szczegółowo później. Jednak podstawową zasadą jest to, że jeden klucz prywatny równa się jednemu „rachunkowi”. Niektórzy użytkownicy decydują się na rezygnację z kontroli nad kluczami prywatnymi, korzystając z usług powiernika zewnętrznego, takiego jak giełda internetowa. W tej książce nauczymy Cię, jak przejąć kontrolę i zarządzać własnymi kluczami prywatnymi.

Kontrola wiąże się z dużą odpowiedzialnością. Jeśli zgubisz klucze prywatne, utracisz dostęp do funduszy i umów. Nikt nie pomoże ci odzyskać dostępu&#x2014 do twoich funduszy, które zostaną zablokowane na zawsze. Oto kilka wskazówek, które pomogą Ci zarządzać tą odpowiedzialnością:

Nie improwizuj kiedy stawką jest bezpieczeństwo . Używaj rozwiązań, które zostały sprawdzone i przetestowane. 

* Im ważniejszy jest rachunek (np. Im wyższa jest wartość kontrolowanych funduszy lub im większe są dostępne inteligentne kontrakty), należy zastosować wyższe środki bezpieczeństwa.

* Najwyższe bezpieczeństwo uzyskuje się z urządzenia ze szczeliną powietrzną, ale ten poziom nie jest wymagany dla każdego konta.

* Nigdy nie przechowuj swojego klucza prywatnego w zwykłej formie, zwłaszcza cyfrowej. Na szczęście większość dzisiejszych interfejsów użytkownika nie pozwala nawet zobaczyć surowego klucza prywatnego.

* (((("klucze prywatne”,"portfele i”)))Klucze prywatne mogą być przechowywane w postaci zaszyfrowanej, jako cyfrowy plik „magazynu kluczy”. Będąc zaszyfrowane, potrzebują hasła do odblokowania. Gdy pojawi się monit o wybranie hasła, ustaw je jako silne (tj. Długie i losowe), utwórz kopię zapasową i nie udostępniaj go. Jeśli nie masz menedżera haseł, zapisz go i przechowuj w bezpiecznym i tajnym miejscu. Aby uzyskać dostęp do konta, potrzebujesz zarówno pliku kluczy, jak i hasła.

* Nie przechowuj żadnych haseł w dokumentach cyfrowych, zdjęciach cyfrowych, zrzutach ekranu, dyskach internetowych, zaszyfrowanych plikach PDF itp. Ponownie, nie poprawiaj bezpieczeństwa. Użyj menedżera haseł lub długopisu i papieru.

* Gdy pojawi się monit o utworzenie kopii zapasowej klucza jako sekwencji słów mnemonicznych, użyj pióra i papieru, aby utworzyć fizyczną kopię zapasową. Nie zostawiaj tego zadania „na później”; zapomnisz. Tych kopii zapasowych można użyć do odbudowania klucza prywatnego na wypadek utraty wszystkich danych zapisanych w systemie lub zapomnienia lub zgubienia hasła. Mogą być jednak również wykorzystywane przez osoby atakujące w celu uzyskania twoich kluczy prywatnych, więc nigdy nie przechowuj ich cyfrowo i przechowuj fizyczną kopię bezpiecznie w zamkniętej szufladzie lub sejfie.

* Przed przeniesieniem dużych kwot (szczególnie na nowe adresy) najpierw wykonaj małą transakcję testową (np. Wartość poniżej 1 USD) i poczekaj na potwierdzenie odbioru.

* Po utworzeniu nowego konta zacznij od wysłania tylko niewielkiej transakcji testowej na nowy adres. Po otrzymaniu transakcji testowej spróbuj odesłać ją ponownie z tego konta. Istnieje wiele powodów, dla których tworzenie konta może się nie powieść, a jeśli poszło nie tak, lepiej dowiedzieć się z niewielką stratą. Jeśli testy działają, wszystko jest w porządku.

* Eksploratorzy bloków publicznych to łatwy sposób na samodzielne sprawdzenie, czy sieć zaakceptowała transakcję. Jednak ta wygoda ma negatywny wpływ na twoją prywatność, ponieważ ujawniasz swoje adresy, aby zablokować odkrywców, którzy mogą cię śledzić.

* Nie wysyłaj pieniędzy na żaden z adresów podanych w tej książce. Klucze prywatne są wymienione w książce i ktoś natychmiast zabierze te pieniądze.

Teraz, gdy omówiliśmy kilka podstawowych najlepszych praktyk w zakresie zarządzania kluczami i bezpieczeństwa, zacznijmy pracę przy użyciu MetaMask!(((range="endofrange", startref="ix_02intro-asciidoc1")))

[[installing_MetaMask]]
=== Rozpoczęcie pracy z MetaMask

(((("Ethereum (ogólnie)”,"Podstawy MetaMask”, id="ix_02intro-asciidoc2”, range=„startofrange”)))(((„MetaMask”,"podstawy”, id=„ix_02intro-asciidoc3”,range="startofrange”)))Otwórz przeglądarkę Google Chrome i przejdź do https://chrome.google.com/webstore/category/extensions [].

Wyszukaj „MetaMask” i kliknij logo lisa. Powinieneś zobaczyć coś takiego jak wynik pokazany w <<metamask_download>>.

[[metamask_download]]
.Strona ze szczegółami rozszerzenia MetaMask Chrome
image::images/metamask_download.png["MetaMask Detail Page"]

Ważne jest, aby sprawdzić, czy pobierasz prawdziwe rozszerzenie MetaMask, ponieważ czasami ludzie są w stanie przekraść się złośliwych rozszerzeń poza filtry Google. Ten prawdziwy:

* Pokazuje ID + nkbihfbeogaeaoehlefnkodbefgpgknn + w pasku adresu
* Jest oferowany przez https://metamask.io
* Ma ponad 1500 opinii
* Ma ponad 1 000 000 użytkowników

Gdy potwierdzisz, że szukasz właściwego rozszerzenia, kliknij „Dodaj do Chrome”, aby je zainstalować.

[[using_MetaMask]]
==== Tworzenie portfela

(((("MetaMask”,"konfiguracja portfela za pomocą”,id="ix_02intro-asciidoc4”, range="startofrange”)))Po zainstalowaniu MetaMask powinna pojawić się nowa ikona (głowa lisa) na pasku narzędzi przeglądarki. Kliknij, aby rozpocząć. Zostaniesz poproszony o zaakceptowanie warunków, a następnie utworzenie nowego portfela Ethereum poprzez wprowadzenie hasła (patrz <<metamask_password>>).

[[metamask_password]]
.Strona hasła do rozszerzenia MetaMask Chrome
image::images/metamask_password.png["MetaMask Password Page"]

[TIP]
====
Hasło kontroluje dostęp do MetaMask, dzięki czemu nikt nie ma dostępu do przeglądarki.
====

((("mnemoniczne słowa kodowe”,"MetaMask i”, id="ix_02intro-asciidoc5”, range="startofrange”))) Po ustawieniu hasła MetaMask wygeneruje dla ciebie portfel i wyświetli _mnemoniczny backup_ składający się z 12 angielskich słów (patrz <<metamask_mnemonic>>). Te słowa mogą być użyte w dowolnym kompatybilnym portfelu, aby odzyskać dostęp do funduszy, jeśli coś stanie się MetaMask lub komputerowi. Nie potrzebujesz hasła do tego odzyskiwania; 12 słów jest wystarczających.

[TIP]
====
Wykonaj kopię zapasową mnemonicznego (12 słów) na papierze, dwa razy. Przechowuj dwie papierowe kopie zapasowe w dwóch oddzielnych bezpiecznych miejscach, takich jak ognioodporny sejf, zamknięta szuflada lub sejf. Traktuj kopie zapasowe papieru jak gotówkę o wartości równej wartości przechowywanej w portfelu Ethereum. Każdy, kto ma dostęp do tych słów, może uzyskać dostęp i ukraść pieniądze.
====

[[metamask_mnemonic]]
.Mnemoniczna kopia zapasowa Twojego portfela, utworzona przez MetaMask
image::images/metamask_mnemonic.png["MetaMask Mnemonic Page"]

Po potwierdzeniu, że bezpiecznie przechowałeś mnemonik, będziesz mógł zobaczyć szczegóły swojego konta Ethereum, jak pokazano w <<metamask_account>>. ((((range="endofrange", startref="ix_02intro-asciidoc5)))

[[metamask_account]]
.Twoje konto Ethereum w MetaMask
image::images/metamask_account.png["MetaMask Account Page"]

Strona konta zawiera nazwę konta (domyślnie „Konto 1”), adres Ethereum (+0x9E713...+ w przykładzie) oraz kolorową ikonę, która pomaga wizualnie odróżnić to konto od innych kont. Na górze strony konta możesz zobaczyć, nad którą siecią Ethereum aktualnie pracujesz (w przykładzie "Sieć główna”).

Gratulacje! Skonfigurowałeś swój pierwszy portfel Ethereum.(((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Przełączanie Sieci

(((„MetaMask”,"wybory sieciowe”)))Jak widać na stronie konta MetaMask, możesz wybierać spośród wielu sieci Ethereum. Domyślnie MetaMask próbuje połączyć się z siecią główną. Inne opcje to publiczne sieci testowe, dowolny wybrany węzeł Ethereum lub węzły z prywatnymi łańcuchami bloków na własnym komputerze (localhost):

Main Ethereum Network:: Główny publiczny blockchain Ethereum. Prawdziwa ETH, prawdziwa wartość i prawdziwe konsekwencje.

Ropsten Test Network:: Publiczny test blockchain i sieć Ethereum. ETH w tej sieci nie ma wartości.

Kovan Test Network:: Publiczny test blockchain i sieć Ethereum z wykorzystaniem protokołu konsensusu Aura z dowodem uprawnień (podpisywanie federacyjne). ETH w tej sieci nie ma wartości. Sieć testowa Kovan jest obsługiwana tylko przez kontrolę parzystości. Inni klienci Ethereum używają protokołu konsensusu Clique, który został zaproponowany później, w celu weryfikacji&#x2013; opartej na autorytecie.

Rinkeby Test Network:: publiczny test blockchain i sieć Ethereum, wykorzystujący protokół konsensusu Clique z dowodem uprawnień (podpisywanie federacyjne). ETH w tej sieci nie ma wartości.

Localhost 8545:: Łączy się z węzłem działającym na tym samym komputerze co przeglądarka. Węzeł może być częścią dowolnego publicznego łańcucha bloków (main lub testnet) lub prywatnego testnet.

Niestandardowe RPC:: Umożliwia połączenie MetaMask z dowolnym węzłem za pomocą interfejsu zdalnego wywoływania procedur (Get RPC) zgodnego z Geth. Węzeł może być częścią dowolnego publicznego lub prywatnego łańcucha bloków.

[NOTE]
====
Twój portfel MetaMask używa tego samego klucza prywatnego i adresu Ethereum we wszystkich sieciach, z którymi się łączy. Jednak saldo adresu Ethereum w każdej sieci Ethereum będzie inne. Twoje klucze mogą kontrolować eter i kontrakty na przykład na Ropsten, ale nie w głównej sieci.
====

[[getting_test_eth]]
==== Zdobycie Trochę Testowego Eteru

((("ether (ogólnie)”,"testnet”)))((("MetaMask”,"i testnet ether”)))((("test ether”,"uzyskiwanie”)))((("testnet",ether for”)))((("wallets”,"testnet ether and”))) Twoim pierwszym zadaniem jest sfinansowanie portfela. Nie będziesz tego robić w głównej sieci, ponieważ prawdziwy eter kosztuje pieniądze, a jego obsługa wymaga nieco więcej doświadczenia. Na razie załadujesz do portfela trochę eteru testnet.

((((„Ropsten Test Network”))) Przełącz MetaMask na _Ropsten Test Network_. Kliknij Deposit, a następnie kliknij Kran Testowy Ropsten. MetaMask otworzy nową stronę internetową, jak pokazano w <<metamask_ropsten_faucet>>.

[[metamask_ropsten_faucet]]
.MetaMask Ropsten Test Faucet
image::images/metamask_ropsten_faucet.png ["MetaMask Ropsten Test Faucet"]

Możesz zauważyć, że strona internetowa zawiera już adres Ethereum portfela MetaMask. MetaMask integruje strony internetowe obsługujące Ethereum z portfelem MetaMask i może „zobaczyć” adresy Ethereum na stronie internetowej, umożliwiając na przykład wysłanie płatności do sklepu internetowego wyświetlającego adres Ethereum. MetaMask może również wypełnić stronę internetową adresem własnego portfela jako adresem odbiorcy, jeśli strona internetowa tego zażąda. Na tej stronie aplikacja kran prosi MetaMask o adres portfela, na który ma wysłać testowy eter.

Kliknij zielony przycisk „poproś 1 eter z kranu”. Zobaczysz identyfikator transakcji pojawiający się w dolnej części strony. Aplikacja kranów utworzyła dla Ciebie transakcję&#x2014; zapłatę do Ciebie. Identyfikator transakcji wygląda następująco:

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

Za kilka sekund nowa transakcja zostanie wydobyta przez górników Ropsten, a Twój portfel MetaMask pokaże saldo 1 ETH. Kliknij identyfikator transakcji, a przeglądarka przeniesie Cię do _block explorer_, czyli strony internetowej, która umożliwia wizualizację i eksplorację bloków, adresów i transakcji. MetaMask korzysta z https://etherscan.io/[Etherscan block explorer], jednego z bardziej popularnych eksploratorów bloków Ethereum. Transakcja zawierająca płatność z kranu testowego Ropsten pokazana jest w <<ropsten_block_explorer>>.

[[ropsten_block_explorer]]
.Etherscan Ropsten eksplorator bloków
image::images/ropsten_block_explorer.png["Etherscan Ropsten Block Explorer"]

Transakcja została zarejestrowana na blockchainie Ropsten i może być w dowolnym momencie przeglądana przez każdego, po prostu szukając identyfikatora transakcji lub http://bit.ly/2Q860Wk[visiting the link].

Spróbuj odwiedzić ten link lub wprowadzić skrót transakcji na stronie _ropsten.etherscan.io_, aby go zobaczyć.

[[wysyłanie_eth_MetaMask]]
==== Wysyłanie Etheru z MetaMask

((("MetaMask”,"wysyłanie eteru z”,id="ix_02intro-asciidoc6”, range ="startofrange”))))((("testowy eter”,"wysyłanie”, id ="ix_02intro-asciidoc7”, range="startofrange”))) Po otrzymaniu pierwszego testowego eteru z kranu testowego Ropsten możesz eksperymentować z wysyłaniem eteru, próbując odesłać trochę z powrotem do kranu. Jak widać na stronie Kran testowy Ropsten, istnieje możliwość „przekazania” 1 ETH kranowi. Ta opcja jest dostępna, więc po zakończeniu testowania możesz zwrócić resztę testowego eteru, aby ktoś inny mógł z niego później skorzystać. Chociaż testowy eter nie ma żadnej wartości, niektórzy go gromadzą, co utrudnia wszystkim innym korzystanie z sieci testowych. Gromadzenie eteru testowego jest źle widziane!

Na szczęście nie jesteśmy zbieraczami eteru testowego. Kliknij pomarańczowy przycisk „1 eter”, aby nakazać MetaMask utworzenie transakcji płacącej 1 eter do kranu. MetaMask przygotuje transakcję i wyświetli okno z potwierdzeniem, jak pokazano w <<send_to_faucet>>.


[[wyślij_do_kranu]]
.Wysyłanie 1 eteru do kranu
image::images/send_to_faucet.png["Sending 1 ether to the faucet"]

Ups! Prawdopodobnie zauważyłeś, że nie możesz dokończyć transakcji&#x2014;. MetaMask twierdzi, że masz niewystarczające saldo. Na pierwszy rzut oka może się to wydawać mylące: masz 1 ETH, chcesz wysłać 1 ETH, więc dlaczego MetaMask mówi, że nie masz wystarczających środków?

((("gaz”,"podstawy”))) Odpowiedź wynika z kosztu gazu. Każda transakcja Ethereum wymaga uiszczenia opłaty, która jest pobierana przez górników w celu potwierdzenia transakcji. Opłaty w Ethereum są naliczane w wirtualnej walucie zwanej gazem. Płacisz za gaz eterem w ramach transakcji.

[NOTE]
====
((("gaz”, "w sieciach testowych”))) Opłaty są również wymagane w sieciach testowych. Bez opłat sieć testowa zachowywałaby się inaczej niż sieć główna, co czyni ją nieodpowiednią platformą testową. Opłaty chronią także sieci testowe przed atakami DoS i źle skonstruowanymi kontraktami (np. Nieskończonymi pętlami), podobnie jak chronią główną sieć.
====

Kiedy wysłałeś transakcję, MetaMask obliczył średnią cenę gazu ostatnich udanych transakcji na poziomie 3 gwei, co oznacza gigawei. Wei to najmniejszy przebieg: [<span class="keep-together">podział</span>] waluty eteru, jak omówiliśmy w <<ether_units>>. Limit gazu ustalany jest na koszt wysłania podstawowej transakcji, która wynosi 21 000 jednostek gazowych. Dlatego maksymalna kwota ETH, którą wydasz, wynosi 3 * 21 000 gwei = 63 000 gwei = 0,000063 ETH. (Należy pamiętać, że średnie ceny gazu mogą się zmieniać, ponieważ są one w dużej mierze determinowane przez górników. W następnym rozdziale zobaczymy, jak możesz zwiększyć / zmniejszyć limit gazu, aby upewnić się, że twoja transakcja ma pierwszeństwo, jeśli zajdzie taka potrzeba).

Wszystko to znaczy: zawarcie transakcji 1 ETH kosztuje 1,000063 ETH. MetaMask myląco zaokrągla to _ w dół_ do 1 ETH, gdy wyświetla sumę, ale faktyczna kwota to 1,000063 ETH, a ty masz tylko 1 ETH. Kliknij Odrzuć, aby anulować tę transakcję.

Zdobądźmy jeszcze trochę eteru testowego! Kliknij ponownie zielony przycisk „poproś 1 eter z kranu” i poczekaj kilka sekund. Nie martw się, kran powinien mieć dużo eteru i da ci więcej, jeśli poprosisz.

Gdy saldo osiągnie 2 ETH, możesz spróbować ponownie. Tym razem po kliknięciu pomarańczowego przycisku darowizny „1 eter” masz wystarczającą saldo, aby dokończyć transakcję. Kliknij Prześlij, gdy MetaMask wyświetli okno płatności. Po tym wszystkim powinieneś zobaczyć saldo 0,999937 ETH, ponieważ wysłałeś 1 ETH do kranu z 0,000063 ETH w gazie. ((((range="endofrange", startref="ix_02intro-asciidoc7")))(((range="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Badanie historii transakcji adresu

'((("adresy”,eksploracja historii transakcji”, id="ix_02intro-asciidoc8”, range="startofrange”))) ((("MetaMask ”,"eksploracja historii transakcji adresu za pomocą”, id=”ix_02intro-asciidoc9",range="startofrange"))) Do tej pory stałeś się ekspertem w używaniu MetaMask do wysyłania i odbierania testowego eteru. Twój portfel otrzymał co najmniej dwie płatności i wysłał co najmniej jedną. Wszystkie te transakcje można wyświetlić za pomocą eksploratora bloków _ropsten.etherscan.io_. Możesz skopiować adres portfela i wkleić go w polu wyszukiwania Eksploratora bloków lub otworzyć MetaMask. Obok ikony konta w MetaMask zobaczysz przycisk pokazujący trzy kropki. Kliknij go, aby wyświetlić menu opcji związanych z kontem (patrz <<metamask_account_context_menu>>).

[[metamask_account_context_menu]]
Menu kontekstowe konta .MetaMask
image::images/metamask_account_context_menu.png["MetaMask Account Context Menu"]

Wybierz „Wyświetl konto w Etherscan”, aby otworzyć stronę internetową w eksploratorze bloków, pokazującą historię transakcji na twoim koncie, jak pokazano w <<block_explorer_account_history>>.

[[block_explorer_account_history]]
.Dodaj historię transakcji na Etherscan
image::images/block_explorer_account_history.png["Address Transaction History on Etherscan"]

Tutaj możesz zobaczyć całą historię transakcji twojego adresu Ethereum. Pokazuje wszystkie transakcje zarejestrowane w blockchainie Ropsten, gdzie twój adres jest nadawcą lub odbiorcą. Kliknij kilka z tych transakcji, aby zobaczyć więcej szczegółów.

Możesz zapoznać się z historią transakcji dowolnego adresu. Spójrz na historię transakcji adresu kranu testowego Ropsten (wskazówka: jest to adres „nadawcy” wymieniony w najstarszej płatności na Twój adres). Możesz zobaczyć cały testowy eter wysłany z kranu do ciebie i na inne adresy. Każda transakcja, którą zobaczysz, może prowadzić do większej liczby adresów i większej liczby transakcji. Wkrótce zagubisz się w labiryncie połączonych danych. Publiczne łańcuchy bloków zawierają ogromne bogactwo informacji, z których wszystkie można eksplorować programowo, jak zobaczymy w przyszłych przykładach(((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange", startref="ix_02intro-asciidoc8")))(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Przedstawiamy Komputer Świata

((("Ethereum (ogólnie)”,"i EVM”)))((("EVM (Maszyna wirtualna Ethereum)”,"jako komputer świata”)))((("komputer świata, Ethereum jako”)))Utworzyłeś teraz portfel i wysłałeś i otrzymałeś eter. Do tej pory traktowaliśmy Ethereum jako kryptowalutę. Ale Ethereum to o wiele, wiele więcej. W rzeczywistości funkcja kryptowaluty jest podporządkowana funkcji Ethereum jako zdecentralizowanego komputera na świecie. ((("inteligentne kontrakty”,'"eter i”)))Ether jest przeznaczony do płacenia za uruchamianie _inteligentnych kontraktów_, które są programami komputerowymi działającymi na emulowanym komputerze o nazwie _Ethereum Virtual Machine_ (EVM).

EVM jest globalnym singletonem, co oznacza, że ​​działa jak globalny komputer z pojedynczą instancją, działający wszędzie. Każdy węzeł w sieci Ethereum uruchamia lokalną kopię EVM w celu sprawdzenia poprawności wykonania kontraktu, podczas gdy blockchain Ethereum rejestruje zmianę stanu komputera tego świata podczas przetwarzania transakcji i inteligentnych kontraktów. Omówimy to bardziej szczegółowo w <<evm_chapter>>.

[[EOA_contracts]]
=== Konta posiadane zewnętrznie (EOA) i umowy

((("konta kontrakru”, patrz także="inteligentne kontrakty”)))((("EOA (konto posiadane zewnętrznie))”,"podstawy”)))(((("Ethereum (ogólnie)”,"EOA i kontrakty”)))((("inteligentne kontrakty”, "podstawy”)))Rodzaj konta utworzonego w portfelu MetaMask nazywa się "zewnętrznym kontem” (EOA). Konta będące własnością zewnętrzną to te, które mają klucz prywatny; posiadanie klucza prywatnego oznacza kontrolę nad dostępem do funduszy lub umów. Prawdopodobnie zgadujesz, że istnieje inny typ konta. Ten inny rodzaj konta jest kontem umowy. Konto umowy ma inteligentny kod umowy, którego zwykły EOA nie może mieć. Ponadto konto umowy nie ma klucza prywatnego. Zamiast tego jest własnością (kontrolowaną) inteligentnej logiki kodu kontraktu: program zapisany w blockchainie Ethereum podczas tworzenia konta umowy i wykonywany przez EVM.

Umowy mają adresy, podobnie jak EOA. Kontrakty mogą również wysyłać i odbierać eter, podobnie jak EOA. Jednak, gdy miejscem docelowym transakcji jest adres umowy, powoduje ona, że ​​umowa ta przebiega w EVM, wykorzystując transakcję i dane transakcji jako dane wejściowe. Oprócz eteru transakcje mogą zawierać _dane_ wskazujące, która konkretna funkcja w kontrakcie ma zostać uruchomiona i jakie parametry przekazać do tej funkcji. W ten sposób transakcje mogą wywoływać funkcje w ramach kontraktów.

Pamiętaj, że ponieważ konto kontraktu nie ma klucza prywatnego, nie może zainicjować transakcji. Tylko EOA mogą inicjować transakcje, ale kontrakty mogą reagować na transakcje, wywołując inne umowy, tworząc złożone ścieżki realizacji. Jednym z typowych zastosowań tego jest EOA wysyłające transakcję żądania do multisignaturowego inteligentnego portfela kontraktów, aby wysłać ETH na inny adres. Typowym wzorcem programowania DApp jest posiadanie kontraktu A wywołującego umowę B w celu utrzymania stanu wspólnego dla użytkowników umowy A.

W kilku następnych sekcjach napiszemy nasz pierwszy kontrakt. Następnie nauczysz się tworzyć, finansować i wykorzystywać ten kontrakt z portfelem MetaMask i testowym eterem w sieci testowej Ropsten.

[[simple_contract_example]]
=== Prosty kontrakt: testowy kran eterowy

(((("konta kontraktu”,"tworzenie”, seealso="Faucet.sol kontrakt”, id="ix_02intro-asciidoc10”, range= "startofrange”))))((("Umowa Faucet.sol (przykład testu)”,"tworzenie”, id="ix_02intro-asciidoc11”, range = "startofrange”)))Ethereum ma wiele różnych języków wysokiego poziomu, z których wszystkie można wykorzystać do napisania umowy i wygenerowania kodu bajtowego EVM. Możesz przeczytać o wielu najważniejszych i najciekawszych w <<high_level_languages>>. Jeden język wysokiego poziomu jest zdecydowanie dominującym wyborem dla inteligentnego programowania kontraktów: Solidność. ((("Wood, Dr. Gavin”, "and Solidity”))) Solidność została stworzona przez dr Gavina Wooda, współautora tej książki, i stała się najczęściej używanym językiem w Ethereum (i nie tylko). Wykorzystamy Solidity do napisania naszej pierwszej umowy.

(((„Solidność”, „faucet.sol i”))) W naszym pierwszym przykładzie (<<solidity_faucet_example>>) napiszemy umowę kontrolującą _faucet_. Użyłeś już kranu, aby uzyskać testowy eter w sieci testowej Ropsten. Kran jest stosunkowo prostą rzeczą: podaje eter pod dowolny żądany adres i może być okresowo uzupełniany. Możesz zaimplementować kran jako portfel kontrolowany przez człowieka lub serwer internetowy.

[[solidity_faucet_example]]
.Faucet.sol: Umowa Solidności wdrażająca kran
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
Wszystkie próbki kodu dla tej książki znajdziesz w podkatalogu _code_ https://github.com/ethereumbook/ethereumbook/[the book's GitHub repository]. W szczególności nasza umowa _Faucet.sol_ obejmuje:

----
code/Solidity/Faucet.sol
----
====

To bardzo prosta umowa, tak prosta, jak to tylko możliwe. Jest to również umowa z wadą, pokazująca szereg złych praktyk i luk w zabezpieczeniach. Nauczymy się, badając wszystkie jego wady w późniejszych sekcjach. Ale na razie przyjrzyjmy się temu, co robi ta umowa i jak to działa, linia po linii. Szybko zauważysz, że wiele elementów Solidity jest podobnych do istniejących języków programowania, takich jak JavaScript, Java lub Cpass: [++].

Pierwszy wiersz to komentarz:

[[comment]]
[source,solidity]
----
// Nasz pierwszy kontrakt to kran!
----

Komentarze są przeznaczone do czytania przez ludzi i nie są zawarte w wykonywalnym kodzie bajtowym EVM. Zazwyczaj umieszczamy je w wierszu przed kodem, który próbujemy wyjaśnić, lub czasami w tym samym wierszu. Komentarze zaczynają się od dwóch ukośników: + // +. Wszystko od pierwszego ukośnika do końca tej linii jest traktowane tak samo jak pusta linia i jest ignorowane.

Następna linia zaczyna się od naszej faktycznej umowy:

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

Ta linia deklaruje obiekt +kontrakt+, podobny do deklaracji +klasy+ w innych językach obiektowych. Definicja kontraktu obejmuje wszystkie linie między nawiasami klamrowymi (pass: [<code>{}</code>]), które definiują _scope_, podobnie jak użycie nawiasów klamrowych w wielu innych językach programowania.

Następnie deklarujemy pierwszą funkcję kontraktu + Faucet +:

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

Funkcja nazywa się +withdraw+ i wymaga jednego argumentu bez znaku liczb całkowitych (+uint+) o nazwie +withdraw_amount+. Jest zadeklarowany jako funkcja publiczna, co oznacza, że ​​można go wywołać na podstawie innych umów. Definicja funkcji następuje pomiędzy nawiasami klamrowymi. Pierwsza część funkcji +withdraw+ określa limit wypłat:

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

Używa wbudowanej funkcji Solidity +require+, aby przetestować warunek wstępny, że +withdraw_amount+ jest mniejsza lub równa 100 000 000 000 000 000 wei, co stanowi podstawową jednostkę eteru (patrz <<ether_denominations>>) i odpowiada 0,1 eteru. Jeśli funkcja +withdraw+ zostanie wywołana z +withdraw_amount+ większą niż ta kwota, funkcja +require+ spowoduje, że wykonanie umowy zostanie zatrzymane i zakończy się niepowodzeniem z wyjątkiem. Zauważ, że instrukcje muszą być zakończone średnikiem w Solidity.

Ta część umowy jest główną logiką naszego kranu. Kontroluje wypływ środków z kontraktu poprzez ograniczenie wypłat. Jest to bardzo prosta kontrola, ale może dać ci wgląd w moc programowalnego blockchaina: zdecentralizowane oprogramowanie kontrolujące pieniądze.

Następnie następuje faktyczna wypłata:

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Dzieje się tu kilka interesujących rzeczy. Obiekt +msg+ jest jednym z danych wejściowych, do których mają dostęp wszystkie kontrakty. Reprezentuje transakcję, która spowodowała wykonanie tej umowy. Atrybut +sender+ to adres nadawcy transakcji. Funkcja +transfer+ to wbudowana funkcja, która przenosi eter z bieżącej umowy na adres nadawcy. Odczytanie go wstecz oznacza +przekazanie+ do +nadawcy+ wiadomości+, która spowodowała wykonanie tej umowy. Funkcja +transfer+ przyjmuje wartość jako jedyny argument. Przekazujemy wartość +withdraw_amount+, która była parametrem do funkcji +withdraw+ zadeklarowanej kilka wierszy wcześniej.

Kolejny wiersz to zamykający nawias klamrowy, wskazujący koniec definicji naszej funkcji +withdraw+.

Następnie deklarujemy jeszcze jedną funkcję:

[[fallback_function]]
[source,solidity]
----
function () external payable {}
----

(((„funkcja rezerwowa”))) Ta funkcja to tak zwana funkcja _fallback_ lub _default_, która jest wywoływana, jeśli transakcja, która wywołała kontrakt, nie spowodowała podania żadnej z zadeklarowanych funkcji w umowie ani żadnej funkcji lub nie zawierał danych. Kontrakty mogą mieć jedną taką domyślną funkcję (bez nazwy) i zwykle jest to ta, która otrzymuje eter. Dlatego jest zdefiniowany jako funkcja zewnętrzna i płatna, co oznacza, że ​​może zaakceptować eter w umowie. Nie robi nic poza akceptowaniem eteru, jak wskazuje pusta definicja w nawiasach klamrowych: [(<code>{}</code>)]. Jeśli dokonamy transakcji, która wyśle ​​eter na adres umowy, tak jakby to był portfel, ta funkcja go obsłuży.

Tuż pod naszą domyślną funkcją znajduje się końcowe nawiasy klamrowe zamykające, które zamykają definicję kontraktu +Faucet+. To jest to! (((range="endofrange", startref="ix_02intro-asciidoc11")))((((range="endofrange", startref="ix_02intro-asciidoc10)))

[[compile_faucet_contract]]
=== Kompilowanie umowy z kranem

(((„kompilacja”,"umowa Faucet.sol”, id="ix_02intro-asciidoc12”, range="startofrange”))))(((„umowa Faucet.sol (przykład testu)”,"kompilacja”, id="ix_02intro-asciidoc13”, range="startofrange”))) Teraz, kiedy mamy naszą pierwszą przykładową umowę, musimy użyć kompilatora Solidity do konwersji kodu Solidity na kod bajtowy EVM, aby mógł on zostać wykonany przez EVM na samym łańcuchu bloków .

Kompilator Solidity jest dostarczany jako samodzielny plik wykonywalny, jako część różnych środowisk i jest pakowany w zintegrowane środowiska programistyczne (IDE). Aby uprościć sprawę, użyjemy jednego z bardziej popularnych IDE, o nazwie _Remix_.

(((„Remix IDE”))) Użyj przeglądarki Chrome (z zainstalowanym wcześniej portfelem MetaMask), aby przejść do Remix IDE na https://remix.ethereum.org [].

Kiedy po raz pierwszy załadujesz Remiks, rozpocznie się od przykładowej umowy o nazwie _ballot.sol_. Nie potrzebujemy tego, więc zamknij go, klikając "x" w rogu karty, jak widać w <<remix_close_tab>>.

[[remix_close_tab]]
. Zamknij domyślną kartę przykładową
image::images/remix_close_tab.png["Close the default example tab"]

Teraz dodaj nową kartę, klikając okrągły znak plus na lewym górnym pasku narzędzi, jak pokazano w <<remix_toolbar>>. Nazwij nowy plik _Faucet.sol_.

[[remix_toolbar]]
. Kliknij znak plus, aby otworzyć nową kartę
image::images/remix_toolbar.png["Click the plus sign to open a new tab"]

Po otwarciu nowej karty skopiuj i wklej kod z naszego przykładu _Faucet.sol_, jak pokazano w <<remix_faucet_load>>.

[[remix_faucet_load]]
. Skopiuj przykładowy kod kranu do nowej karty
image::images/remix_faucet_load.png["Copy the Faucet example code into the new tab"]

Po załadowaniu umowy _Faucet.sol_ do Remix IDE, IDE automatycznie skompiluje kod. Jeśli wszystko pójdzie dobrze, zobaczysz zielone pole z „Kranem” po prawej stronie, pod zakładką Kompiluj, potwierdzające pomyślną kompilację (patrz <<remix_compile>>).

[[remix_compile]]
.Remix z powodzeniem kompiluje kontrakt Faucet.sol
image::images/remix_compile.png[""]

Jeśli coś pójdzie nie tak, najbardziej prawdopodobnym problemem jest to, że Remix IDE korzysta z wersji kompilatora Solidity innej niż 0.5.12. W takim przypadku nasza dyrektywa pragma uniemożliwi kompilację _Faucet.sol_. Aby zmienić wersję kompilatora, przejdź do karty Ustawienia, ustaw wersję na 0.5.12 i spróbuj ponownie.

Kompilator Solidity skompilował teraz nasz _Faucet.sol_ do kodu bajtowego EVM. Jeśli jesteś ciekawy, kod bajtowy wygląda następująco:

[[faucet_bytecode]]
----
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST PUSH1 0xE5 DUP1 PUSH2 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN
STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3F JUMPI
PUSH1 0x0 CALLDATALOAD PUSH29
0x100000000000000000000000000000000000000000000000000000000
SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x41 JUMPI
JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH1 0x4B JUMPI PUSH1 0x0 DUP1 REVERT
JUMPDEST PUSH1 0x5F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1
SWAP2 SWAP1 POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8
0x16345785D8A0000 DUP2 GT ISZERO ISZERO ISZERO PUSH1 0x77 JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND
PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1
0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO
ISZERO PUSH1 0xB6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP STOP LOG1 PUSH6
0x627A7A723058 KECCAK256 PUSH9 0x13D1EA839A4438EF75 GASLIMIT CALLVALUE LOG4 0x5f
PUSH24 0x7541F409787592C988A079407FB28B4AD000290000000000
----

Czy nie cieszysz się, że używasz języka wysokiego poziomu, takiego jak Solidity, zamiast programować bezpośrednio w kodzie bajtowym EVM? Ja też!(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Tworzenie umowy w Blockchain

(((„blockchain”, „tworzenie kontraktu”, id="ix_02intro-asciidoc14", range="startofrange")))(((„Umowa Faucet.sol (przykład testu)”, „ o blockchain”, id="ix_02intro-asciidoc15", range="startofrange")))Tak więc mamy umowę. Skompilowaliśmy go do kodu bajtowego. Teraz musimy „zarejestrować” umowę na blockchainie Ethereum. Będziemy używać sieci testowej Ropsten do testowania naszej umowy, więc jest to blockchain, do którego chcemy ją przesłać.

(((„zerowy adres”, „rejestracja umowy”))) Rejestracja umowy w łańcuchu bloków obejmuje utworzenie specjalnej transakcji, której miejscem docelowym jest adres +0x0000000000000000000000000000000000000000+, znany również jako _zerowy adres_. Adres zerowy to specjalny adres, który informuje blockchain Ethereum, że chcesz zarejestrować umowę. Na szczęście Remix IDE zajmie się tym wszystkim i wyśle ​​transakcję do MetaMask.

(((„Remix IDE”, id="ix_02intro-asciidoc16", range="startofrange")))Najpierw przejdź do zakładki Uruchom i wybierz Wstrzyknięty Web3 z rozwijanego menu Środowisko. To łączy Remix IDE z portfelem MetaMask, a poprzez MetaMask do sieci testowej Ropsten. Gdy to zrobisz, możesz zobaczyć Ropsten w środowisku. Ponadto w polu wyboru Konto wyświetla adres portfela (patrz <<remix_run>>).

[[remix_run]]
.Remix Karty IDE Run, z wybranym środowiskiem Wstrzykiwania Web3
image::images/remix_run.png["Remix IDE Run tab, with Injected Web3 environment selected"]

Tuż pod ustawieniami Run, które właśnie potwierdziłeś, jest umowa + Faucet +, gotowa do utworzenia. Kliknij przycisk Wdróż pokazany w <<remix_run>>.

Remiks skonstruuje specjalną transakcję „tworzenia”, a MetaMask poprosi o zatwierdzenie, jak pokazano w <<remix_metamask_create>>. Zauważysz, że transakcja tworzenia kontraktu nie zawiera eteru, ale zawiera 262 bajty danych (skompilowana umowa) i zużywa 10 gwei w gazie. Kliknij Prześlij, aby zatwierdzić.

[[remix_metamask_create]]
.MetaMask showing the contract creation transaction
image::images/remix_metamask_create.png["MetaMask showing the contract creation transaction"]

Teraz musisz poczekać. Wydobycie kontraktu na Ropsten zajmie około 15 do 30 sekund. Remiks wydaje się nie robić wiele, ale bądź cierpliwy.

Po utworzeniu umowa pojawia się na dole zakładki Uruchom (patrz <<remix_contract_interact>>).

[[remix_contract_interact]]
.The Faucet contract is ALIVE!
image::images/remix_contract_interact.png["The Faucet contract is ALIVE!"]

Zauważ, że kontrakt + Faucet + ma teraz swój własny adres: Remix pokazuje go jako  &#x201c;Faucet pod 0x72e...c7829&#x201d; (chociaż twój adres, losowe litery i cyfry będą inne). Mały symbol schowka po prawej stronie pozwala skopiować adres umowy do schowka. Wykorzystamy to w następnej sekcji. (((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Interakcja z umową

(((„Umowa Faucet.sol (przykład testowy)”, „interakcja z”, id="ix_02intro-asciidoc17", range="startofrange")))Podsumujmy to, czego do tej pory się nauczyliśmy: umowy Ethereum to programy, które kontrolować pieniądze, które działają w maszynie wirtualnej zwanej EVM. Są tworzone przez specjalną transakcję, która przekazuje swój kod bajtowy do zapisania w łańcuchu bloków. Po utworzeniu w blockchain mają adres Ethereum, podobnie jak portfele. Za każdym razem, gdy ktoś wysyła transakcję na adres umowy, powoduje ona, że ​​umowa zostanie uruchomiona w EVM, a transakcja zostanie wprowadzona. Transakcje wysłane do przekazania: [<span class="keep-together">contract</span>] adresy mogą zawierać eter lub dane lub oba te elementy. Jeśli zawierają eter, są „zdeponowane” na saldzie kontraktu. Jeśli zawierają dane, mogą określić nazwaną funkcję w kontrakcie i wywołać ją, przekazując argumenty do funkcji.

[[view_contract_address]]
==== Wyświetlanie adresu umowy w Eksploratorze bloku

(((„Umowa Faucet.sol (przykład testowy)”, „wyświetlanie adresu umowy w eksploratorze bloków”))) Mamy umowę zarejestrowaną na blockchain i możemy zobaczyć, że ma ona adres Ethereum. Sprawdźmy to w eksploratorze bloków _ropsten.etherscan.io_ i zobaczmy, jak wygląda kontrakt. W Remix IDE skopiuj adres kontraktu, klikając ikonę schowka obok jego nazwy (patrz <<remix_contract_address>>).

[[remix_contract_address]]
. Skopiuj adres umowy z Remix
image::images/remix_contract_address.png["Copy the contract address from Remix"]

Pozostaw remiks otwarty; wrócimy do tego później. Teraz przejdź do przeglądarki do _ropsten.etherscan.io_ i wklej adres w polu wyszukiwania. Powinieneś zobaczyć historię adresów Ethereum kontraktu, jak pokazano w <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.Wyświetl adres kontraktu Kran w eksploratorze bloków Etherscan
image::images/etherscan_contract_address.png["View the Faucet contract address in the etherscan block explorer"]

[[fund_contract]]
==== Finansowanie umowy

(((„Umowa Faucet.sol (przykład testowy)”, „wysyłanie eteru do”, id="ix_02intro-asciidoc18", range="startofrange"))) Na razie umowa ma tylko jedną transakcję w swojej historii: transakcja tworzenia umowy. Jak widać, umowa również nie zawiera eteru (saldo zerowe). To dlatego, że nie wysłaliśmy żadnego eteru do kontraktu w transakcji tworzenia, chociaż mogliśmy.

Nasz kran potrzebuje funduszy! Naszym pierwszym projektem będzie użycie MetaMask do wysłania eteru do kontraktu. Nadal powinieneś mieć adres umowy w schowku (jeśli nie, skopiuj go ponownie z Remiksu). Otwórz MetaMask i wyślij do niego 1 eter, dokładnie tak jak na każdy inny adres Ethereum (patrz <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
. Wyślij 1 eter na adres umowy
image::images/metamask_send_to_contract.png[""]

Za minutę, jeśli ponownie załadujesz eksplorator bloków Etherscan, wyświetli on kolejną transakcję na adres kontraktu i zaktualizowane saldo 1 eteru.

Pamiętasz domyślną zewnętrzną płatną funkcję bez nazwy w naszym kodzie _Faucet.sol_? Wyglądała ona tak:

[[fallback_function_review]]
[source,solidity]
----
function () external payable {}
----

Gdy wysłałeś transakcję na adres umowy, bez danych określających, która funkcja ma zostać wywołana, wywołała tę funkcję domyślną. Ponieważ zadeklarowaliśmy go jako +payable+, zaakceptował i zdeponował 1 eter na saldzie kontraktu. Twoja transakcja spowodowała, że ​​umowa działała w EVM, aktualizując jej saldo. Sfinansowałeś swój kran!((((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Odstąpienie od naszej umowy

(((„Umowa Faucet.sol (przykładowy test))”, „wypłata środków z”, id="ix_02intro-asciidoc19", range="startofrange")))(((„wycofanie środków z umowy”, i id="ix_02intro-asciidoc20", range="startofrange"))) Następnie wycofajmy trochę funduszy z kranu. Aby dokonać wypłaty, musimy skonstruować transakcję, która wywołuje funkcję +withdraw+ i przekazuje do niej argument +withdraw_amount+. Aby uprościć na razie, Remix zbuduje dla nas tę transakcję, a MetaMask przedstawi ją do naszej akceptacji.

Wróć do zakładki Remiks i spójrz na kontrakt na zakładce Uruchom. Powinieneś zobaczyć pomarańczowe pole z etykietą +withdraw+ z polem oznaczonym +uint256 withdraw_amount+ (patrz <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
Funkcja wycofania Faucet.sol, w Remiksie
image::images/remix_contract_interact.png["The withdraw function of Faucet.sol, in Remix"]

To jest interfejs Remiksu do umowy. Pozwala nam konstruować transakcje, które wywołują funkcje określone w umowie. Wprowadzimy +withdraw_amount+ i klikniemy przycisk wypłaty, aby wygenerować transakcję.

Najpierw wymyślmy +withdraw_amount+. Chcemy spróbować wycofać 0,1 eteru, co stanowi maksymalną kwotę dozwoloną przez naszą umowę. Pamiętaj, że wszystkie wartości walutowe w Ethereum są wewnętrznie denominowane w wei, a nasza funkcja  +withdraw+  oczekuje, że kwota +withdraw_amount+ będzie również denominowana w wei. Potrzebna ilość to 0,1 eteru, czyli 100 000 000 000 000 000 wei (1, po którym następuje 17 zer).



[TIP]
====
Z powodu ograniczenia w JavaScript, tak duża liczba jak 10 ^ 17 nie może być przetwarzana przez Remix. Zamiast tego ujęliśmy go w podwójne cudzysłowy, aby umożliwić Remixowi otrzymanie go jako ciągu i manipulowanie nim jako +BigNumber+. Jeśli nie umieścimy go w cudzysłowie, Remix IDE nie przetworzy go i wyświetli „Argumenty błędu kodowania: Błąd: asercja nie powiodła się”.
====

Wpisz „100000000000000000” (z cudzysłowami) w polu +withdraw_amount+ i kliknij przycisk wycofania (patrz <<remix_withdraw>>).

[[remix_withdraw]]
. Kliknij „withdraw” w Remiksie, aby utworzyć transakcję wypłaty
image::images/remix_withdraw.png[""]

MetaMask wyświetli okno transakcji do zatwierdzenia. Kliknij Potwierdź, aby wysłać wezwanie do wypłaty do umowy (patrz <<metamask_withdraw>>).

[[metamask_withdraw]]
.Transakcja MetaMask w celu wywołania funkcji wycofania
image::images/metamask_withdraw.png["MetaMask transaction to call the withdraw function"]

Poczekaj chwilę, a następnie ponownie załaduj eksplorator bloków Etherscan, aby zobaczyć transakcję odzwierciedloną w historii adresów kontraktów + Faucet + (patrz <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan pokazuje transakcję wywołującą funkcję wypłaty
image::images/etherscan_withdrawal_tx.png["Etherscan shows the transaction calling the withdraw function"]


Teraz widzimy nową transakcję z adresem kontraktu jako miejscem docelowym i wartością 0 eteru. Saldo kontraktu zmieniło się i wynosi teraz 0,9 eteru, ponieważ wysłał nam 0,1 eteru zgodnie z żądaniem. Ale nie widzimy transakcji „OUT” w _ historii adresów umów_.

Gdzie jest wypłata wychodząca? Na stronie historii adresów umowy pojawiła się nowa karta o nazwie Transakcje wewnętrzne. ((("transakcja wewnętrzna (komunikat)”)))Ponieważ transfer eteru 0,1 pochodzi z kodu kontraktu, jest to transakcja wewnętrzna (zwana również "wiadomością”). Kliknij tę kartę, aby ją zobaczyć (patrz <<etherscan_withdrawal_internal>>).


Ta "transakcja wewnętrzna” została wysłana przez umowę w tym wierszu kodu (z funkcji pass: [<code><span class="keep-together">wycofanie</span></code>] w _Faucet.sol_):

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Reasumując: wysłałeś transakcję z portfela MetaMask, która zawierała instrukcje dotyczące danych, aby wywołać funkcję +withdraw+  z argumentem +withdraw_amount+ 0,1 eteru. Ta transakcja spowodowała uruchomienie umowy w EVM. Ponieważ EVM uruchomił funkcję +Faucet+ kontrakt +withdraw+, najpierw wywołał funkcję +require+ i potwierdził, że żądana kwota była mniejsza lub równa maksymalnej dozwolonej wypłacie 0,1 eteru. Następnie wywołano funkcję +require+, aby wysłać Ci eter. Uruchomienie funkcji +require+ wygenerowało wewnętrzną transakcję, która zdeponowała 0,1 eteru na Twoim adresie portfela, z salda kontraktu. To jest pokazane na karcie Transakcje wewnętrzne w Etherscan (((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))).(((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan pokazuje wewnętrzną transakcję przeniesienia eteru z kontraktu
image::images/etherscan_withdrawal_internal.png["Etherscan shows the internal transaction transferring ether out from the contract"]

[[intro_conclusion]]
=== Conclusions

W tym rozdziale konfigurujesz portfel za pomocą MetaMask i finansujesz go za pomocą kranu w sieci testowej Ropsten. Otrzymałeś eter na adres Ethereum swojego portfela, a następnie wysłałeś eter na adres Ethereum kranu.

Następnie napisałeś umowę na kran w Solidity. Użyłeś Remix IDE do skompilowania umowy do kodu bajtowego EVM, a następnie użyłeś Remiksu do utworzenia transakcji i utworzyłeś kontrakt + Faucet + na blockchainie Ropsten. Po utworzeniu umowa + Faucet + miała adres Ethereum, a Ty wysłałeś jej trochę eteru. Na koniec zbudowałeś transakcję, aby wywołać funkcję + wycofanie + i pomyślnie poprosiłeś o eter 0,1. Kontrakt sprawdził wniosek i wysłał Ci 0,1 eteru z transakcją wewnętrzną.

To może nie wydawać się dużo, ale właśnie z powodzeniem współpracowałeś z oprogramowaniem kontrolującym pieniądze na zdecentralizowanym komputerze świata.

Zrobimy o wiele więcej inteligentnego programowania umów w <<smart_contracts_chapter>> i poznamy najlepsze praktyki i względy bezpieczeństwa w <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))