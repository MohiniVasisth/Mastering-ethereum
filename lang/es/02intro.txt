[[intro_chapter]]
== Ethereum: Lo Esencial

((("Ethereum (en general)","lo esencial", id="ix_02intro-asciidoc0", range="startofrange")))En este capítulo empezaremos a explorar Ethereum, aprendiendo cómo usar billeteras, cómo crear transacciones, y cómo ejecutar un contrato inteligente básico.

[[ether_units]]
=== Unidades de la moneda éter

((("unidades de la moneda")))((("Ethereum (en general)","unidades de la moneda")))La unidad de la moneda de Ethereum es denominada _éter_, también denominado como "ETH" o con los símbolos &#926; (de la letra del alfabeto griego "Xi" que se parece a una E con estilos; o, menos frecuentemente, &#9830;: por ejemplo, 1 éter, o 1 ETH, o &#926;1, o &#9830;1.

[TIP]
====
Use el carácter Unicode +U+039E+ para &#926; y +U+2666+ para &#9830;.
====

El éter está subdividido en unidades más pequeñas, hasta la unidad mas pequeña posible, la cual es llamada _wei_. Un wei es la trillonésima parte de un éter (1 ETH = 1 * 10^18 wei, o bien 1 ETH = 1.000.000.000.000.000.000 weis). Es posible escuchar también a algunas personas referirse a la moneda en sí como "Ethereum", pero es un error común entre los principiantes. Ethereum es el sistema, éter es la moneda.

El valor del éter es siempre representado internamente en Ethereum como un entero sin signo denominado en wei. Cuando ejecutamos una transacción de 1 éter, la transacción se registra con 1000000000000000000 de weis como el valor de la misma.

Las distintas denominaciones del éter tienen tanto un _nombre científico_, usando el Sistema Unitario Internacional (_SI_), como un nombre coloquial rindiendo tributo a las grandes mentes de la computación y la criptografía.

La <<ether_denominations>> muestra las distintas unidades, sus nombres coloquiales (los comunes), y sus nombres en el SI. Además, la tabla muestra todas las denominaciones en wei (primera fila), que es como se representa internamente el valor, con el éter mostrado como 10^18^ wei en la 7ª fila.

[[ether_denominations]]
.Denominaciones del éter y nombres de unidades
[options="header"]
|===
| Valor (en wei) | Exponente | Nombre común | Nombre en SI
| 1 | 1 | wei | Wei
| 1.000 | 10^3^ | Babbage | Kilowei o femtoéter
| 1.000.000 | 10^6^ | Lovelace | Megawei o picoéter
| 1.000.000.000 | 10^9^ | Shannon | Gigawei o nanoéter
| 1.000.000.000.000 | 10^12^ | Szabo | Microéter o micro
| 1.000.000.000.000.000 | 10^15^ | Finney | Miliéter o mili
| _1.000.000.000.000.000.000_ | _10^18^_ | _Éter_ | _Éter_
| 1.000.000.000.000.000.000.000 | 10^21^ | Grand | Kiloéter
| 1.000.000.000.000.000.000.000.000 | 10^24^ | | Megaéter
|===

[[choosing_eth_wallet]]
=== Eligiendo una Cartera para Ethereum

((("Ethereum (en general)","opciones de carteras")))((("carteras","escogiendo")))((("carteras","definición")))El término "cartera" ha llegado a significar una cierta variedad de cosas, aunque todas ellas están relacionadas, y son prácticamente la misma. Utilizaremos el término "cartera" para referirnos a la aplicación de software que nos ayuda a manejar nuestras cuentas en Ethereum. En pocas palabras, una cartera de Ethereum es nuestra puerta de entrada al Sistema Ethereum. Ella guarda nuestras llaves y puede crear y transmitir transacciones por nosotros. Escoger una cartera de Ethereum puede ser difícil, porque hay muchas opciones diferentes con diversas funciones y diseños. Algunas son más apropiadas para principiantes, y otras son más apropiadas para expertos. La plataforma Ethereum en sí todavía está siendo mejorada, y las "mejores" carteras, usualmente son las que se adaptan a los cambios que vienen con las actualizaciones a la plataforma.

Pero no hay que preocuparse! Si escogemos una cartera, y no nos gusta cómo funciona&#x2014;o si nos gusta al principio pero luego queremos probar algo distinto&#x2014;es bastante sencillo cambiar de cartera. Todo lo que necesitamos, es hacer una transacción que envíe nuestros fondos desde la antigua cartera a la nueva, o bien, exportar nuestras llaves privadas, e importarlas hacia la nueva cartera.

Hemos seleccionado tres tipos diferentes de carteras para usarlas como ejemplos en todo el libro: una cartera móvil, una cartera de escritorio y una cartera basada en la web. Elegimos estas tres carteras porque representan una amplia gama de complejidad y características. Sin embargo, la selección de estas carteras no es un aval de su calidad o seguridad. Simplemente son un buen punto de partida para demostraciones y pruebas.

((("llaves privadas","carteras y")))Recuérdese que para que una aplicación de cartera funcione, debe tener acceso a nuestras llaves privadas, por lo que es vital que solo descarguemos y usemos aplicaciones de carteras de fuentes confiables. Afortunadamente, en general, cuanto más popular es una aplicación de cartera, es probable que sea más confiable. Sin embargo, es una buena práctica evitar poner "todos los huevos en la misma canasta" y tener nuestras cuentas de Ethereum repartidas en un par de carteras.

Las siguientes son buenas aplicaciones para comenzar:

MetaMask:: ((("MetaMask")))MetaMask es una cartera de extensión para navegadores web que se ejecuta en nuestro navegador (bien sea Chrome, Firefox, Opera o Brave Browser). Es fácil de usar y conveniente para las pruebas, ya que puede conectarse a una variedad de nodos de Ethereum y probar distintas cadenas de bloques. MetaMask es una cartera basada en la web.

Jaxx:: ((("Jaxx")))((("carteras","Jaxx")))Jaxx es una cartera multi-plataforma y multi-divisas que se ejecuta en una variedad de sistemas operativos, incluidos Android, iOS, Windows, macOS, y Linux. Suele ser una buena opción para los nuevos usuarios, ya que está diseñada para simplificar y facilitar su uso. Jaxx es una cartera tanto móvil como de escritorio, dependiendo de dónde se le instale.

MyEtherWallet (MEW):: ((("Ethereum Classic (ETC)","Emerald Wallet y")))((("MyEtherWallet (MEW)")))((("carteras","Emerald Wallet")))((("carteras","MyEtherWallet")))MyEtherWallet es una cartera basada en la web que se ejecuta en cualquier navegador. Tiene múltiples características sofisticadas que exploraremos en muchos de nuestros ejemplos. MyEtherWallet es una cartera basada en la web.

Emerald Wallet:: ((("Emerald Wallet")))Emerald Wallet está diseñada para funcionar con la cadena de bloques de Ethereum Classic, pero es compatible con otras cadenas de bloques basadas en Ethereum. Es una aplicación de escritorio de código abierto y funciona en Windows, macOS y Linux. Emerald Wallet puede ejecutar un nodo completo o conectarse a un nodo remoto público, operando en un modo "ligero". También tiene una herramienta complementaria para realizar todas las operaciones desde la línea de comandos.

Comenzaremos instalando MetaMask en un escritorio&#x2014;pero primero, discutiremos brevemente como controlar y manejar las claves

[[control_responsibility]]
=== Control y Responsabilidad

((("Ethereum (en general)","control y responsabilidad", id="ix_02intro-asciidoc1", range="startofrange")))Las cadenas de bloques abiertas como Ethereum son importantes porque ellas operan como sistemas descentralizados. Eso significa muchas cosas, pero un aspecto crucial es que cada usuario de Ethereum puede&#x2014;y debería&#x2014 controlar sus propias llaves privadas, que son las que controlan el acceso a los fondos y a los contratos inteligentes. Nosotros algunas veces llamamos a la combinación de accesos a los fondos y a los contratos inteligentes como una "cuenta" o "cartera". Estos términos pueden llegar a ser un poco complejos de entender y para comprender su funcionamiento, entraremos en más detalles sobre ellos más adelante. Como principio fundamental, sin embargo podemos decir que una llave privada es igual a una "cuenta". Algunos usuarios eligen dejar el control de sus llaves privadas en custodia de terceras entidades, como un casa de cambios en línea. En este libro enseñaremos como tomar el control y gestión de nuestras propias llaves privadas.

Con el control y poder viene también una gran responsabilidad. Si perdemos las llaves privadas, perdemos el acceso a nuestros fondos y contratos. Nadie podrá ayudarnos a recuperar el acceso&#x2014;nuestros fondos quedarán bloqueados para siempre. Aquí se muestran algunos cuantos consejos para ayudarnos a gestionar esta responsabilidad.

* Evítese improvisar con la seguridad. Hay que utilizar enfoques estandarizados bien comprobados y verificados.

* Cuanto más importante sea la cuenta (por ejemplo, cuanto mayor sea el valor de los fondos controlados o más importantes sean los contratos inteligentes accesibles), se deben tomar mayores medidas de seguridad.

* La seguridad más alta se obtiene con un dispositivo con aislamiento de burbuja, pero este nivel no es necesario para todas las cuentas.

* Las llaves privadas jamás deben almacenarse en forma simple, especialmente en modo digital. Afortunadamente, la mayoría de las interfaces de usuario actuales ni siquiera nos permitirán ver la llave privada sin procesar.

* ((("llaves privadas","carteras y")))Las llaves privadas se pueden almacenar en forma encriptada, como un archivo de "almacén de llaves" digital. Al estar encriptados, necesitan una contraseña para desbloquearse. Cuando se nos solicite eligir una contraseña, hagámosla segura (es decir, larga y aleatoria), hay que hacer una copia de seguridad que jamas debemos compartir. Si no tenemos un administrador de contraseñas, hay que anotarla y guardarla en un lugar seguro y secreto. Para acceder a nuestra cuenta, necesitaremos tanto el archivo de almacén de llaves como la contraseña.

* Las contraseñas no deben almacenarse en documentos digitales, fotos digitales, capturas de pantalla, unidades en línea, archivos PDF cifrados, etc. Nuevamente, no improvisemos con la seguridad. Utilicemos un administrador de contraseñas o lápiz y papel.

* Cuando se nos solicite hacer una copia de seguridad de una llave en forma de una secuencia de palabras mnemónicas, hay que usar lápiz y papel para realizar esa copia de seguridad en físico. Esta tarea no puede dejarse "para más tarde"; se nos puede olvidar. Estas copias de seguridad se pueden utilizar para reconstruir nuestra llave privada en caso de pérdida de datos almacenados en nuestro sistema, o en caso de olvidar o perder nuestra contraseña. Sin embargo, los atacantes también pueden usarlas para obtener nuestras llaves privadas, por lo que nunca podemos almacenarlas digitalmente y por lo que hay que mantener la copia física almacenada a buen resguardo, en una gaveta con llave o caja fuerte.

* Antes de transferir grandes cantidades (especialmente a nuevas direcciones), es mejor realizar primero una pequeña transacción de prueba (por ejemplo, con un valor inferior a $1) y esperamos la confirmación del recibo.

* Cuando creemos una nueva cuenta, mejor es comenzar enviando solo una pequeña suma en una transacción de prueba a la nueva dirección. Una vez que reciba la transacción de prueba, intente enviar de regreso desde esa nueva cuenta a la cuenta de origen. Hay muchas razones por las cuales la creación de cuentas puede salir mal, y si sale mal, es mejor descubrirlo con una pequeña pérdida. Si las pruebas funcionan, todo estará en orden.

* Los exploradores de bloques públicos son una manera fácil de ver de forma independiente si la red ha aceptado una transacción. Sin embargo, esta comodidad tiene un impacto negativo en nuestra privacidad, porque revela nuestras direcciones a los exploradores de bloques, que pueden rastrearnos. 

* No envíe dinero a ninguna de las direcciones que se muestran en este libro. Las llaves privadas que les corresponden están listadas en el libro y un tercero tomaría ese dinero de inmediato.

Ahora que hemos cubierto algunas de las mejores prácticas básicas para la administración de llaves y seguridad, ¡comencemos a trabajar usando MetaMask!(((range="endofrange", startref="ix_02intro-asciidoc1")))

[[installing_MetaMask]]
=== Comenzando con MetaMask

((("Ethereum (en general)","fundamentos de MetaMask", id="ix_02intro-asciidoc2", range="startofrange")))((("MetaMask","fundamentos", id="ix_02intro-asciidoc3", range="startofrange")))Abrimos el navegador Google Chrome y vamos a: https://chrome.google.com/webstore/category/extensions [].

Buscamos "MetaMask" y damos click sobre el logo del zorro. Debería verse algo así como el resultado mostrado en la <<metamask_download>>.

[[metamask_download]]
.La página de detalles de la extensión Chrome MetaMask.
image::images/metamask_download.png["La página de detalles de la extensión Chrome MetaMask"]

Es importante verificar que estemos descargando la extensión real de MetaMask, ya que a veces las personas pueden subir extensiones maliciosas evitando los filtros de Google. La aplicación correcta corresponderá con lo siguiente:

* Un ID mostrando +nkbihfbeogaeaoehlefnkodbefgpgknn+ en la barra de direcciones
* Es ofrecido por https://metamask.io
* Tiene más de 1.500 comentarios
* Tiene más de 1.000.000 de usuarios

Una vez confirmado que estamos ante la extensión correcta, hacemos click en "Agregar a Chrome" para instalarla.

[[using_MetaMask]]
==== Creando una Cartera

((("MetaMask","configuración de carteras con", id="ix_02intro-asciidoc4", range="startofrange")))Una vez que MetaMask está instalado, deberíamos ver un nuevo icono (la cabeza de un zorro) en la barra de herramientas de nuestro navegador. Pulsamos click en él para comenzar. Se nos pedirá que aceptemos los términos y condiciones y luego crearemos nuestra nueva cartera Ethereum ingresando una contraseña (véase la <<metamask_password>>).

[[metamask_password]]
.La ventana de contraseña de la extensión Chrome MetaMask
image::images/metamask_password.png["La ventana de contraseña de la extensión Chrome MetaMask"]

[TIP]
====
La contraseña controla el acceso a MetaMask, por lo que no puede ser utilizada por otra persona con acceso a nuestro navegador.
====

((("palabras código mnemónicas","MetaMask y", id="ix_02intro-asciidoc5", range="startofrange")))Una vez que hayamos establecido una contraseña, MetaMask generará una cartera para nosotros y nos mostrará un _respaldo mnemónico_ que consta de 12 palabras en inglés (véase la <<metamask_mnemonic>>). Estas palabras se pueden usar en cualquier cartera compatible para recuperar el acceso a nuestros fondos en caso de que algo le suceda a MetaMask o nuestra computadora. No necesitamos la contraseña para esta recuperación; las 12 palabras son suficientes.

[TIP]
====
Hay que guardar esta frase mnemónica (de 12 palabras) en papel dos veces, al menos. Hay que guardar las dos copias de seguridad en papel en lugares separados y seguros, lugares resistentes al fuego, una caja fuerte, un lugar cerrado con llaves, o en un depósito seguro. Hay que tratar estas copias de seguridad en papel como si fuesen dinero físico que tiene el mismo valor que almacenaremos en nuestra cartera de Ethereum. Cualquiera con acceso a estas palabras puede conseguir entrar y robar nuestro dinero.
====

[[metamask_mnemonic]]
.El respaldo de seguridad mnemónico de cartera, creado por MetaMask
image::images/metamask_mnemonic.png["El respaldo de seguridad mnemónico de cartera, creado por MetaMask"]

Una vez confirmado que tenemos guardada la frase mnemónica de forma segura, tendremos la posibilidad de ver los detalles de esta cartera Ethereum, como se muestra en la <<metamask_account>>.(((range="endofrange", startref="ix_02intro-asciidoc5")))

[[metamask_account]]
.Cuenta de Ethereum en MetaMask
image::images/metamask_account.png["Primera Cuenta de Ethereum en MetaMask"]

La ventana de cuentas muestra el nombre de nuestra primera cuenta ("Account 1" por defecto), una dirección Ethereum  (+0x9E713...+ en el ejemplo), y un icono que sobresalta para ayudarnos a distinguir visualmente esta cuenta de otras cuentas. En la parte superior de la ventana de la cuenta puede verse con cual red Ethereum estamos actualmente trabajando  ("Main Network" en el ejemplo). 

En hora buena! Hemos configurado nuestra primera cartera Ethereum.(((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Cambiando de Red

((("MetaMask","elección de red")))Como puede verse en la ventana de cuentas de MetaMask, podemos elegir entre varias redes Ethereum. De forma predeterminada, MetaMask intentará conectarse a la red principal. Las otras opciones son redes de prueba públicas, también cualquier nodo Ethereum que se haya elegido o incluso nodos que ejecutan cadenas de bloques privadas en nuestra propia computadora (localhost):

Red Principal de Ethereum:: La principal cadena de bloques pública de Ethereum. Maneja ETH real, valor real y trae consecuencias reales.

Red de Pruebas de Ropsten:: Una de las redes y cadena de bloques pública de prueba para Ethereum. El ETH sobre esta red no tiene valor.

Red de Pruebas de Kovan:: Red y cadena de bloques de prueba pública de Ethereum que utiliza el protocolo de consenso Aura con prueba de autoridad (firmas federadas). El ETH sobre esta red no tiene valor. La red de prueba Kovan esta soportada solamente por Parity. Otros clientes Ethereum utilizan el protocolo de consenso Clique, el cual fue propuesto después, para pruebas de autoridad &#x2013;basadas en verificación.

Red de Prueba Rinkeby:: Otra cadena de bloques y red de pruebas pública de Ethereum, la cual utiliza el protocolo de consenso Clique con prueba de autoridad (firma federada). El ETH en esta red no tiene valor.

Localhost 8545:: Se conecta a un nodo que se ejecuta en la misma computadora del navegador. El nodo puede ser parte de cualquier cadena de bloques pública (principal o red de pruebas) o de alguna red de pruebas privada.

RPC personalizado:: Permite conectar MetaMask a cualquier nodo con una interfaz de llamada a procedimiento remoto (del inglés "Remote Procedure Call" o RPC) compatible con Geth. El nodo puede ser parte de cualquier cadena de bloques pública o privada.

[NOTE]
====
La cartera MetaMask usa la misma llave privada y la misma dirección Ethereum en todas las redes a las que se conecta. Sin embargo, el saldo de la dirección Ethereum en cada red Ethereum será diferente. Ciertas llaves podrán controlar el éter y los contratos en Ropsten, por ejemplo, pero no así en la red principal.
====

[[getting_test_eth]]
==== Obtener un Poco de Éter de Prueba

((("éter (en general)","testnet")))((("MetaMask","y éter de la testnet")))((("éter de la testnet","obteniendo")))((("testnet","éter para")))((("carteras","éter de la testnet y")))La primera tarea es conseguir fondos para nuestra cartera. No lo haremos en la red principal porque el éter real cuesta dinero y su manejo requiere un poco más de experiencia. Por ahora, cargaremos nuestra cartera con éter de la testnet.

((("Ropsten Test Network")))Cambiemos la conexión de MetaMask a la red de pruebas Ropsten, indicada en la cartera como _Ropsten Test Network_. Pulsamos clic en Depositar, luego pulsamos clic en Ropsten Test Faucet. MetaMask abrirá una nueva página web, como se muestra en la <<metamask_ropsten_faucet>>.

[[metamask_ropsten_faucet]]
.Faucet de Prueba para MetaMask Ropsten
image::images/metamask_ropsten_faucet.png["Faucet de Prueba para MetaMask Ropsten"]

Podemos notar que la página web contiene nuestra dirección Ethereum de la cartera MetaMask. MetaMask integra páginas web habilitadas para Ethereum con nuestra cartera MetaMask y puede "ver"  direcciones Ethereum en la página web, permitiéndonos por ejemplo enviar pagos a una tienda en linea mostrándola como dirección Ethereum. MetaMask puede también insertar en la página web nuestras propias direcciones de la billetera como la dirección del beneficiario si la página web lo solicita. En esta página web la aplicación de grifo, o "faucet" está preguntándole a MetaMask por la dirección de la cartera para enviarle éter de prueba a ella.

Pulsamos click en el botón verde "request 1 ether from faucet". Veremos el ID de la transacción que aparecerá en la parte inferior de la página. La aplicación faucet ha creado una transacción&#x2014;un pago hacia nosotros. El ID de la transacción luce como esto:

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

En pocos segundos, la nueva transacción será minada por los mineros de la red Ropsten y la cartera MetaMask mostrará el saldo de 1 ETH. Pulsamos click sobre el ID de la transacción y el navegador nos lleva a un _explorador de bloques_, el cual es un sitio web que nos permite visualizar y explorar los bloques, direcciones, y transacciones de una cadena de bloques. MetaMask utiliza el explorador:  https://etherscan.io/[Etherscan block explorer], que es uno de los exploradores de bloques de Ethereum más populares. La transacción que contiene el pago de Ropsten del faucet de pruebas es mostrado en la <<ropsten_block_explorer>>.  

[[ropsten_block_explorer]]
.Explorador de bloques Etherscan Ropsten
image::images/ropsten_block_explorer.png["Explorador de bloques Etherscan Ropsten"]

La transacción ha sido registrada en la cadena de bloques Ropsten y puede ser consultada en cualquier momento por cualquiera, simplemente buscando por el ID de la transacción, o http://bit.ly/2Q860Wk[visitando este enlace].

Podemos tratar de visitar ese enlace, o ingresar el hash de la transacción en el sitio web _ropsten.etherscan.io_, para verla por nosotros mismos.

[[sending_eth_MetaMask]]
==== Enviando Éter desde MetaMask

((("MetaMask","enviando éter desde", id="ix_02intro-asciidoc6", range="startofrange")))((("éter de prueba","enviando", id="ix_02intro-asciidoc7", range="startofrange")))Una vez que hemos recibido nuestro primer éter de prueba desde el grifo de la red Ropsten, podremos experimentar enviando éter de vuelta al grifo. Como puede verse en la página de la aplicación faucet de Ropsten hay una opción para "donar" 1 ETH al faucet. Esta opción está disponible para que una vez que hayamos realizado las pruebas podamos retornar el resto de nuestros éter de prueba, y así otra persona más adelante pueda utilizarlos también para hacer sus pruebas. Incluso aunque el éter de prueba no tiene valor, algunas personas lo acumulan, dificultando a todos los demás usar la red de pruebas. Acumular éter de prueba está mal visto.

Afortunadamente nosotros no somos acaparadores de éter de prueba. Al hacer click en el botón naranja "1 ether" para informarle a MetaMask que cree una transacción de pago al faucet de 1 éter. MetaMask preparará una transacción y una ventana emergente aparecerá con la confirmación como se muestra en la <<send_to_faucet>>.


[[send_to_faucet]]
.Enviando 1 éter al grifo
image::images/send_to_faucet.png["Enviando 1 éter al grifo"]

Oops! probablemente notaremos que no se puede completar la transacción&#x2014;MetaMask dice que no hay suficiente saldo. A primera vista esto puede parecer confuso: tenemos 1 ETH, queremos enviar 1 ETH, porque MetaMask está diciendo que tu no hay fondos suficientes?

((("gas","fundamentos")))La respuesta es por el costo del _gas_. Cada transacción Ethereum requiere del pago de una comisión, la cual cobran los mineros por validar la transacción. Las comisiones en Ethereum se pagan en una moneda virtual llamada gas. Pagamos por el gas con éter, como parte de la transacción.

[NOTE]
====
((("gas","en redes de prueba")))Incluso en las redes de prueba hay que pagar comisiones. Sin esas comisiones, una red de pruebas se comportaría de manera diferente a la red principal, por lo que sería una plataforma de pruebas inadecuada. La existencia de comisiones también protege a las redes de prueba de los ataques por denegación de servicios o "DoS" y de los contratos mal construidos (por ejemplo, contentivos de bucles infinitos), del mismo modo que protegen a la red principal.
====

Cuando enviamos nuestra transacción, MetaMask ha calculado el precio promedio del gas de las transacciones exitosas más recientes como 3 gwei, que significa "gigawei". El wei es la pass:[<span class="keep-together">subdivisión</span>] mas pequeña de la moneda éter, como discutimos en <<ether_units>>. El límite de gas es asignado como el costo de enviar una transacción básica, el cual es 21.000 unidades de gas. Por lo tanto la cantidad máxima de ETH que podríamos gastar es 3 * 21.000 gwei = 63.000 gwei = 0,000063 ETH. (Téngase en cuenta que el precio promedio del gas puede fluctuar, ya que está determinado principalmente por los mineros. Veremos en capítulos posteriores como podemos incrementar/reducir nuestro límite de gas para asegurar que nuestra transacción tome precedencia si lo necesitamos.)

Todo esto para decir lo siguiente: hacer una transacción de 1 ETH cuesta 1,000063 ETH. MetaMask redondea confusamente ese número hacia _abajo_ a 1 ETH cuando muestra el total, pero la cantidad real que necesitamos es de 1,000063 ETH mientras que solo tenemos 1 ETH. Pulsamos clic en Rechazar para cancelar esta transacción.

Vamos a tomar mas éter de prueba! Haciendo click en el botón verde "request 1 ether from faucet" de nuevo y esperando unos segundos. No se preocupen, el faucet debería tener mucho éter y nos dará más si se lo pedimos.

Una vez que tenemos un saldo de 2 ETH, podemos intentar de nuevo. Esta vez cuando presionemos click sobre el botón de donación naranja "1 ether", tendremos suficiente saldo para completar la transacción. Pulsamos click en Enviar cuando MetaMask muestre la ventana emergente de pago. Después de todo esto, deberíamos ver un saldo de 0.999937 ETH, porque enviamos 1 ETH al faucet con 0.000063 ETH en gas.(((range="endofrange", startref="ix_02intro-asciidoc7")))(((range="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Explorando el Historial de Transacciones de una Dirección.

((("direcciones","explorando el historial de transacciones de", id="ix_02intro-asciidoc8", range="startofrange")))((("MetaMask","explorando el historial de transacciones de una dirección con", id="ix_02intro-asciidoc9", range="startofrange")))Por ahora nos hemos convertido en expertos al utilizar MetaMask para enviar y recibir éter de prueba. Nuestra cartera ha recibido al menos 2 pagos y ha enviado al menos uno. Podemos ver todas estas transacciones utilizando el explorador _ropsten.etherscan.io_. Podemos también copiar la dirección de nuestra cartera y pegarla en un explorador de bloques o hacer que MetaMask abra la página para nosotros. Junto al icono de nuestra cuenta MetaMask, veremos un botón mostrando tres puntos. Pulsamos click sobre él para mostrar un menú de opciones de cuentas relacionadas (véase la <<metamask_account_context_menu>>).

[[metamask_account_context_menu]]
.Menú contextual de las cuentas de MetaMask
image::images/metamask_account_context_menu.png["Menú contextual de las cuentas de MetaMask"]

Seleccionamos "View account on Etherscan" para abrir una página web en el explorador de bloques mostrando el historial de transacciones de esa cuenta, como se muestra en la <<block_explorer_account_history>>.

[[block_explorer_account_history]]
.Historial de transacciones de direcciones en Etherscan
image::images/block_explorer_account_history.png["Historial de transacciones de direcciones en Etherscan"]

Aquí podemos ver el historial completo de transacciones de nuestra dirección de Ethereum. Ésta muestra todas las transacciones registradas en la cadena de bloques de Ropsten donde nuestra dirección es de quien envía o quien recibe. Al pulsar clic en algunas de estas transacciones podremos ver más detalles.

Podemos explorar el historial de transacciones de cualquier dirección. Echemos un vistazo al historial de transacciones de la dirección de Ropsten del faucet (pista: es la dirección del remitente o "sender" que aparece en el pago más antiguo de nuestra dirección). Puede verse todo el éter de prueba enviado desde el grifo hacia nosotros y hacia otras direcciones. Cada transacción que vemos puede llevarnos a más direcciones y más transacciones. En poco tiempo nos perderíamos en el laberinto de datos interconectados. Las cadenas de bloques públicas contienen una enorme cantidad de información, toda la cual se puede explorar programáticamente, como veremos en ejemplos futuros(((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange", startref="ix_02intro-asciidoc8"))).(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Introducción al Computador Global

((("Ethereum (en general)","y la EVM")))((("EVM (Ethereum Virtual Machine)","como computador global")))((("computador global, Ethereum como")))Ahora hemos creado una cartera y hemos enviado y recibido éter. Hasta ahora, hemos tratado a Ethereum como una criptomoneda. Pero Ethereum es mucho, mucho más. De hecho, la función de la criptomoneda está subordinada a la función de Ethereum como una computadora mundial descentralizada. ((("contratos inteligentes","éter y")))El éter está destinado a pagar las ejecuciones de los _contratos inteligentes_, que son programas informáticos que se ejecutan en una computadora emulada llamada _Máquina Virtual de Ethereum_ (del inglés "Ethereum Virtual Machine" o EVM).

La EVM es un "singleton", es decir, que opera como si fuese un computador global con una única instancia, ejecutándose en todas partes . Cada nodo de la red Ethereum ejecuta una copia local de la EVM para validar la ejecución de contratos, mientras que la cadena de bloques de Ethereum registra los cambios de _estado_  de este computador global a medida que procesa transacciones y contratos inteligentes. Discutiremos esto con más detalle en el <<evm_chapter>>.

[[EOA_contracts]]
=== Contratos y Cuentas Manejadas Externamente (EOAs)

((("cuentas de contratos", seealso="smart contracts")))((("EOA (Externally Owned Account)","fundamentos")))((("Ethereum (en general)","EOAs y contratos")))((("contratos inteligentes","fundamentos")))El tipo de cuenta que hemos creado en nuestra billetera MetaMask suele denominarse _cuenta de titularidad externa_ (del inglés "Externally Owned Account" o EOA). Las cuentas de titularidad externa son aquellas que tienen una llave privada; Tener la llave privada significa controlar el acceso a los fondos o contratos. Probablemente ya puede advertirse que hay otro tipo de cuenta. Ese otro tipo de cuenta es una _cuenta de contrato_. Una cuenta de contrato tiene un código de contrato inteligente, que una EOA simple no puede tener. Además, una cuenta de contrato no tiene una llave privada. En cambio, es propiedad (y está controlada) por la lógica de su código de contrato inteligente: el programa de software registrado en la cadena de bloques de Ethereum en la creación de la cuenta del contrato y ejecutado por la EVM.

Los contratos tienen direcciones, al igual que las EOA. Los contratos también pueden enviar y recibir éter, al igual que las EOA. Sin embargo, cuando el destino de una transacción es una dirección de contrato, se esta desencadenando la ejecución del código de ese contrato en la EVM, utilizando la transacción y los datos de la transacción como datos de entrada. Además de éter, las transacciones pueden contener _datos_ que indican qué función específica en el contrato se debe ejecutar y qué parámetros pasar a esa función. De esta forma, las transacciones pueden _invocar_ funciones dentro de los contratos.

Téngase en cuenta que debido a que una cuenta de contrato no tiene una llave privada, no puede _iniciar_ una transacción. Solo las EOA pueden iniciar transacciones, pero los contratos pueden _reaccionar_ a las transacciones llamando a otros contratos y creando rutas de ejecución complejas. Un uso típico de esto es una EOA que envía una transacción de solicitud a una cartera de contrato inteligente de firma múltiple para enviar algo de ETH a otra dirección. Un patrón típico de programación de DApp es que el Contrato A llame al Contrato B para mantener un estado compartido entre los usuarios del Contrato A.

En las próximas secciones, escribiremos nuestro primer contrato. Luego, aprenderemos a crear, financiar y usar ese contrato con nuestra cartera MetaMask y probar éter en la red de prueba de Ropsten.

[[simple_contract_example]]
=== Un Contrato Simple: Un Grifo de Éter de Prueba

((("cuentas de contrato","creándolas", seealso="Faucet.sol contract", id="ix_02intro-asciidoc10", range="startofrange")))((("contrato Faucet.sol (ejemplo de prueba)","creándolo", id="ix_02intro-asciidoc11", range="startofrange")))Ethereum tiene muchos lenguajes de alto nivel diferentes, todos los cuales se pueden usar para escribir un contrato y producir código binario compatible para la EVM. Puede leer sobre muchos de los más destacados e interesantes en <<high_level_languages>>. Uno de estos lenguajes de alto nivel es, con mucho, la opción dominante para la programación de contratos inteligentes: Solidity. ((("Wood, Dr. Gavin","y Solidity")))Solidity fue creado por el Dr. Gavin Wood, el coautor de este libro, y se ha convertido en el lenguaje más utilizado en Ethereum (y más allá). Usaremos Solidity para escribir nuestro primer contrato.

((("Solidity","faucet.sol y")))Para nuestro primer ejemplo (<<solidity_faucet_example>>), escribiremos un contrato que controle un grifo o, del inglés, _faucet_. Ya usamos un grifo para obtener el éter de prueba en la red de prueba de Ropsten. Un grifo es algo relativamente simple: da éter a cualquier dirección que lo solicite y se puede rellenar periódicamente. Podemos implementar un grifo como una cartera controlada por un humano o un servidor web.

[[solidity_faucet_example]]
.Faucet.sol: La implementación de un contrato de grifo de monedas en Solidity
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
Se pueden hallar todas las muestras de código para este libro en el subdirectorio _code_ de https://github.com/ethereumbook/ethereumbook/[el repositorio de GitHub del libro]. Específicamente, nuestro contrato _Faucet.sol_ está en:

----
code/Solidity/Faucet.sol
----
====

Este es un contrato muy simple, tan simple como podemos hacerlo. También es un contrato _defectuoso_, que demuestra una serie de malas prácticas y vulnerabilidades de seguridad. Aprenderemos examinando todos sus defectos en secciones posteriores. Pero por ahora, veamos qué hace este contrato y cómo funciona, línea por línea. Se notará rápidamente que muchos elementos de Solidity son similares a los lenguajes de programación existentes, como JavaScript, Java o Cpass: [++].

La primera línea es un comentario:

[[comment]]
[source,solidity]
----
// Nuestro primer contrato es un grifo!
----

Los comentarios son para que los puedan leer los humanos y no están incluidos en el código binario ejecutable de la EVM. Por lo general, los ponemos en la línea antes del código que estamos tratando de explicar, o en ocasiones en la misma línea. Los comentarios comienzan con dos barras diagonales: +//+. Todo, desde la primera barra hasta el final de esa línea, se trata igual que una línea en blanco y se ignora.

La siguiente línea es donde comienza nuestro contrato real:

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

Esta línea declara un objeto de contrato o +contract+, similar a la declaración de una +clase+ en otros lenguajes orientados a objetos. La definición del contrato incluye todas las líneas entre los corchetes de llaves (pass:[<code>{}</code>]), que definen una _extensión_, muy parecida a cómo se usan los corchetes de llaves en muchos otros lenguajes de programación.

A continuación, declaramos la primera función del contrato +Faucet+:

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

La función se llama retirar o +withdraw+ y toma un argumento entero sin signo (+uint+) llamado +withdraw_amount+. Se declara como función pública, lo que significa que puede ser invocada por otros contratos. La definición de la función sigue, entre corchetes de llaves. La primera parte de la función +withdraw+ establece un límite a los retiros:

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

Utiliza la función de Solidity incorporada denominada +require+ para probar una pre-condición: que la variable +withdraw_amount+ sea menor o igual a 100,000,000,000,000,000 wei, donde wei es la unidad base del éter (véase la <<ether_denominations>>) y el monto total equivale a 0,1 éter. Si la función +withdraw+ se invoca con un monto de +withdraw_amount+ mayor que esa cantidad, la función +require+ aquí hará que la ejecución del contrato se detenga y falle con una _excepción_. Téngase en cuenta que las declaraciones deben terminarse con punto y coma en Solidity.

Esta parte del contrato es la lógica principal de nuestro grifo. Controla el flujo de fondos hacia fuera del contrato al poner un límite a los retiros. Es un control muy simple, pero puede darnos una idea del poder de una cadena de bloques programable: software descentralizado controlando al dinero.

Luego viene el retiro real:

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Aquí están sucediendo un par de cosas interesantes. El objeto +msg+ (mensaje) es una de las entradas a las que pueden acceder todos los contratos. Representa la transacción que desencadenó la ejecución de este contrato. El atributo +sender+ es la dirección del remitente de la transacción. La función +transfer+ es una función incorporada en Solidity, que transfiere el éter del contrato actual a la dirección del remitente. Al leerlo al revés, esto significa +transferir+ al +remitente+ del +mesaje+ que desencadenó la ejecución de este contrato. La función +transfer+ toma una cantidad como único argumento. Pasamos el valor de la variable +withdraw_amount+ como el valor de ese argumento y que era el parámetro a la función +withdraw+ declarada unas líneas antes.

La siguiente línea es el corchete de llave de cierre, que indica el final de la definición de nuestra función +withdraw+.

A continuación, declaramos una función más:

[[fallback_function]]
[source,solidity]
----
function () external payable {}
----

((("función fallback")))Esta función es una función denominada _fallback_ o _default_, la cual es invocada si la transacción que desencadenó el contrato no nombró ninguna de las funciones declaradas en el contrato, o ninguna función en absoluto o no contenía datos. Los contratos pueden tener solo una de estas funciones predeterminadas (sin nombre) y suele ser la que recibe el éter. Es por eso que se define como una función externa y pagadera, lo que significa que puede aceptar éter en el contrato. No hace nada más que aceptar el éter, como lo indica la definición vacía entre los corchetes de llaves pass:[(<code>{}</code>)]. Si realizamos una transacción que envía éter a la dirección del contrato, como si fuera una cartera, esta función lo manejará.

Justo debajo de nuestra función predeterminada está el corchete de llave de cierre final, que cierra la definición del contrato +Faucet+. ¡Eso es todo!(((range="endofrange", startref="ix_02intro-asciidoc11")))(((range="endofrange", startref="ix_02intro-asciidoc10")))

[[compile_faucet_contract]]
=== Compilando el Contrato Faucet

((("compilando","el contrato Faucet.sol", id="ix_02intro-asciidoc12", range="startofrange")))((("contrato Faucet.sol (ejemplo de prueba)","compilando", id="ix_02intro-asciidoc13", range="startofrange")))Ahora que tenemos nuestro primer contrato de ejemplo, necesitamos usar un compilador de Solidity para convertir el código de Solidity en código binario (compatible con la EVM) para que la EVM pueda ejecutarlo en la propia cadena de bloques.

El compilador de Solidity viene como un ejecutable independiente, como parte de varios marcos, y se incluye en entornos de desarrollo integrados (IDE). Para simplificar las cosas, usaremos uno de los IDE más populares, llamado _Remix_.

((("Remix IDE")))Usaremos el navegador Chrome (con la cartera MetaMask que instalamos anteriormente) para navegar hacia la Remix IDE en https://remix.ethereum.org[].

Cuando Remix se carga por primera vez, comenzará con un contrato de muestra llamado _ballot.sol_. No lo necesitamos, así que mejor es cerrarlo haciendo clic en la +x+ de la esquina de la pestaña, como se ve en la <<remix_close_tab>>.

[[remix_close_tab]]
.Cerrar la pestaña de ejemplo predeterminada
image::images/remix_close_tab.png["Cerrar la pestaña de ejemplo predeterminada"]

Ahora, agregamos una nueva pestaña haciendo clic en el signo más circular en la barra de herramientas superior izquierda, como se ve en la <<remix_toolbar>>. Llámese al nuevo archivo, _Faucet.sol_.

[[remix_toolbar]]
.Haga clic en el signo más para abrir una nueva pestaña
image::images/remix_toolbar.png["Haga clic en el signo más para abrir una nueva pestaña"]

Una vez que tenga la nueva pestaña abierta, copie y pegue el código de nuestro ejemplo _Faucet.sol_, como se ve en la <<remix_faucet_load>>.

[[remix_faucet_load]]
.Copiar el código de ejemplo de Faucet en la nueva pestaña
image::images/remix_faucet_load.png["Copiar el código de ejemplo de Faucet en la nueva pestaña"]

Una vez que se haya cargado el contrato _Faucet.sol_ en Remix IDE, el IDE compilará automáticamente el código. Si todo va bien, veremos un cuadro verde con &quot;Faucet&quot; a la derecha, debajo de la pestaña Compilar, confirmando la compilación exitosa (véase la <<remix_compile>>).

[[remix_compile]]
.Remix compila con éxito el contrato Faucet.sol
image::images/remix_compile.png["Remix compila con éxito el contrato Faucet.sol"]

Si algo sale mal, el problema más probable es que Remix IDE esté usando una versión del compilador de Solidity diferente a la 0.5.12. En ese caso, nuestra directiva pragma evitará que _Faucet.sol_ compile. Para cambiar la versión del compilador, nos dirigimos a la pestaña Configuración, y establecemos la versión en 0.5.12, para luego intentar compilar nuevamente.

El compilador de Solidity ahora ha compilado nuestro _Faucet.sol_ en código binario compatible con la EVM. Por si se tiene la curiosidad, el código binario se ve así:

[[faucet_bytecode]]
----
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST PUSH1 0xE5 DUP1 PUSH2 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN
STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3F JUMPI
PUSH1 0x0 CALLDATALOAD PUSH29
0x100000000000000000000000000000000000000000000000000000000
SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x41 JUMPI
JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH1 0x4B JUMPI PUSH1 0x0 DUP1 REVERT
JUMPDEST PUSH1 0x5F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1
SWAP2 SWAP1 POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8
0x16345785D8A0000 DUP2 GT ISZERO ISZERO ISZERO PUSH1 0x77 JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND
PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1
0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO
ISZERO PUSH1 0xB6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP STOP LOG1 PUSH6
0x627A7A723058 KECCAK256 PUSH9 0x13D1EA839A4438EF75 GASLIMIT CALLVALUE LOG4 0x5f
PUSH24 0x7541F409787592C988A079407FB28B4AD000290000000000
----

¿No se siente un alivio al estar usando un lenguaje de alto nivel como Solidity, en lugar de programar directamente en código binario de la EVM? ¡Pues yo sí!(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Creando el Contrato en la Cadena de Bloques

((("cadena de bloques","creando un contrato en", id="ix_02intro-asciidoc14", range="startofrange")))((("contrato Faucet.sol (ejemplo de prueba)","en la cadena de bloques", id="ix_02intro-asciidoc15", range="startofrange")))Entonces, tenemos un contrato. Lo hemos compilado en código binario. Ahora, necesitamos "registrar" el contrato en la cadena de bloques de Ethereum. Usaremos la red de pruebas de Ropsten para probar nuestro contrato, así que esa es la cadena de bloques a la que queremos enviarlo.

((("dirección cero","registro del contrato")))Registrar un contrato en la cadena de bloques implica la creación de una transacción especial cuyo destino es la dirección +0x0000000000000000000000000000000000000000+, también conocida como la _dirección cero_. La dirección cero es una dirección especial que le dice a la cadena de bloques de Ethereum que deseamos registrar un contrato. Afortunadamente, Remix IDE se encargará de todo eso por nosotros y enviará la transacción a MetaMask.

((("Remix IDE", id="ix_02intro-asciidoc16", range="startofrange")))Primero, nos cambiamos a la pestaña "Run" y seleccionamos "Injected Web3" en el cuadro "Enviroment" de selección desplegable. Esto conecta el IDE de Remix a la cartera MetaMask y, a través de MetaMask, a la red de pruebas de Ropsten. Una vez que lo hagamos, podremos ver Ropsten en el cuadro "Enviroment". Además, en el cuadro de selección de Cuenta (Account) se mostrará la dirección de nuestra cartera (véase la <<remix_run>>).

[[remix_run]]
.Pestaña "Run" del IDE de Remix, con "Injected Web3" seleccionado en "Enviroment"
image::images/remix_run.png["Pestaña Run del IDE de Remix, con "Injected Web3" seleccionado en "Enviroment""]

Justo debajo de la pestaña "Run" que acabamos de configurar, está el contrato +Faucet+, ya listo para ser creado. Pulsamos click en el botón "Deploy" que se muestra en la <<remix_run>>.

Remix construirá la transacción especial de "creación" del contrato y MetaMask nos pedirá que la aprobemos, como se muestra en la <<remix_metamask_create>>. Puede notarse que la transacción de creación del contrato no tiene éter, pero tiene 262 bytes de datos (la data del contrato compilado) y consumirá 10 gwei en gas. Pulsamos click en "Submit" (o "Confirm" para otras versiones de la cartera) para aprobarlo.

[[remix_metamask_create]]
.MetaMask mostrando la transacción de creación del contrato
image::images/remix_metamask_create.png["MetaMask mostrando la transacción de creación del contrato"]

Ahora esperamos un poco. El contrato tardará entre 15 y 30 segundos en ser confirmado en la red de Ropsten. Remix no parece estar haciendo mucho, pero seamos pacientes.

Una vez creado el contrato, su nombre aparece en la parte inferior de la pestaña "Run" (véase la <<remix_contract_interact>>).

[[remix_contract_interact]]
.¡El contrato Faucet está VIVO!
image::images/remix_contract_interact.png["¡El contrato Faucet está VIVO!"]

Obsérvese que el contrato +Faucet+ ahora tiene una dirección propia: Remix lo muestra como &#x201c;Faucet at 0x72e...c7829&#x201d; (aunque las direcciones en cada cartera, las letras y números aleatorios serán diferentes). El pequeño símbolo del portapapeles a la derecha nos permite copiar la dirección del contrato en nuestro portapapeles. Esta dirección la usaremos en la siguiente sección.(((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Interactuando con el Contrato

((("contrato Faucet.sol (ejemplo de prueba)","interactuando con", id="ix_02intro-asciidoc17", range="startofrange")))Recapitulemos lo que hemos aprendido hasta ahora: los contratos de Ethereum son programas que controlan fondos, que se ejecutan dentro de una máquina virtual llamada EVM. Se crean mediante una transacción especial que envía su código binario para que se registre en la cadena de bloques. Una vez que se crean en la cadena de bloques, tienen una dirección de Ethereum, al igual que las carteras. Cada vez que alguien envía una transacción a una dirección de contrato, el contrato se ejecuta en la EVM, con la transacción como entrada. Las transacciones enviadas a las direcciones de un pass:[<span class="keep-together">contrato</span>] pueden contener éter o datos, o ambos. Si contienen éter, es porque ha sido "depositado" en el saldo del contrato. Si contienen datos, los datos pueden especificar una función nombrada en el contrato y llamarla, pasando argumentos a esa función.

[[view_contract_address]]
==== Visualizando la Dirección del Contrato en un Explorador de Bloques

((("contrato Faucet.sol (ejemplo de prueba)","visualizando la dirección del contrato en un explorador de bloques")))Ahora tenemos un contrato registrado en la cadena de bloques, y podemos ver que tiene una dirección de Ethereum. Echemos un vistazo en el explorador de bloques _ropsten.etherscan.io_ y veamos cómo luce un contrato. En el IDE de Remix, copiamos la dirección del contrato haciendo clic en el icono del portapapeles junto a su nombre (véase la <<remix_contract_address>>).

[[remix_contract_address]]
.Copiando la dirección del contrato desde Remix
image::images/remix_contract_address.png["Copiando la dirección del contrato desde Remix"]

Mas vale mantener Remix abierto; volveremos a esta aplicación más tarde. Ahora, navegamos con el browser a _ropsten.etherscan.io_ y pegamos la dirección en el cuadro de búsqueda. Debería verse el historial de direcciones de Ethereum del contrato, como se muestra en la <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.Visualizando la dirección del contrato Faucet en el explorador de bloques de Etherscan
image::images/etherscan_contract_address.png["Visualizando la dirección del contrato Faucet en el explorador de bloques de Etherscan"]

[[fund_contract]]
==== Financiando del Contrato

((("contrato Faucet.sol (ejemplo de prueba)","enviando éter a", id="ix_02intro-asciidoc18", range="startofrange")))Por ahora, el contrato solo tiene una transacción en su historial: la transacción de creación del contrato. Como puede verse, el contrato tampoco tiene éter (su saldo es cero). Eso es debido a que no hemos enviado ningún éter al contrato en la transacción de creación, aunque podríamos haberlo hecho.

¡Nuestro grifo necesita fondos! Nuestro primer proyecto será utilizar MetaMask para enviar éter al contrato. Aún deberíamos tener la dirección del contrato en nuestro portapapeles (si no, copiemoslo nuevamente desde Remix). Abrimos MetaMask y le enviamos 1 éter, exactamente como lo haríamos para con cualquier otra dirección de Ethereum (véase la <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
.Enviando 1 éter a la dirección del contrato
image::images/metamask_send_to_contract.png["Enviando 1 éter a la dirección del contrato"]

En un minuto, si refrescamos el explorador de bloques de Etherscan, éste mostrará otra transacción a la dirección del contrato y un saldo actualizado de 1 éter.

¿Recuerdan la función pagadera externa predeterminada sin nombre, en el código de nuestro contrato _Faucet.sol_? Se veía así:

[[fallback_function_review]]
[source,solidity]
----
function () external payable {}
----

Cuando enviamos la transacción a la dirección del contrato, sin datos que especificaran a qué función llamar, invocamos realmente a esta función predeterminada. Debido a que la declaramos como pagadera o +payable+, el contrato aceptó y depositó el éter que le enviamos en el saldo de su cuenta. Nuestra transacción hizo que el contrato se ejecutara en la EVM, actualizando su saldo. ¡Hemos financiado el grifo!(((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Retirando Fondos de Nuestro Contrato

((("contrato Faucet.sol (ejemplo de prueba)","retirando fondos de", id="ix_02intro-asciidoc19", range="startofrange")))((("retiro de fondos del contrato", id="ix_02intro-asciidoc20", range="startofrange")))A continuación, retiraremos algunos fondos del grifo. Para retirar, tenemos que construir una transacción que invoque a la función retirar, o +withdraw+ y que le pase un argumento, el +withdraw_amount+. Para mantener las cosas simples por ahora, Remix construirá esa transacción para nosotros y MetaMask la presentará para nuestra aprobación.

Regresamos a la página de Remix y desplegamos el campo del contrato, en la pestaña "Run". Debería verse un recuadro naranja etiquetado +withdraw+ con una entrada de campo etiquetada +uint256 withdraw_amount+ (véase la <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
.La función de retiro de Faucet.sol, en Remix
image::images/remix_contract_interact.png["La función de retiro de Faucet.sol, en Remix"]

Esta es la interfaz Remix del contrato. Nos permite construir transacciones que invocan a las funciones definidas en el contrato. Ingresaremos una cifra para +withdraw_amount+ y hacemos clic en el botón "withdraw" para generar la transacción.

Pero primero, averigüemos la cantidad apropiada para +withdraw_amount+. Queremos intentar retirar 0.1 ether, que es la cantidad máxima permitida por nuestro contrato. Recuerde que todos los valores de moneda en Ethereum están denominados en wei internamente, y nuestra función +withdraw+ espera que la cifra de +withdraw_amount+ también se denomine en wei. La cantidad que queremos es 0,1 de éter, que es 100.000.000.000.000.000 wei (un 1 seguido de 17 ceros).



[TIP]
====
Debido a limitaciones en JavaScript, Remix no puede procesar un número tan grande como 10^17. En cambio, lo encerramos entre comillas dobles, para permitir que Remix lo reciba como una cadena y lo manipule como un +BigNumber+. Si no lo escribimos entre comillas, el IDE de Remix no lo procesará y mostrará el siguiente mensaje de error "Error encoding arguments: Error: Assertion failed."
====

Escribimos "100000000000000000" (con todo y comillas) en el cuadro +withdraw_amount+ y pulsamos clic en el botón de retiro (véase la <<remix_withdraw>>).

[[remix_withdraw]]
.Pulsar click en "withdraw", en Remix para crear una transacción de retiro
image::images/remix_withdraw.png["Pulsar click en "withdraw", en Remix para crear una transacción de retiro"]

MetaMask abrirá una ventana de transacción para que la aprobemos. Pulsamos clic en "Submit" (o "Confirm" para versiones mas recientes) para enviar nuestra invocación de retiro al contrato (véase la <<metamask_withdraw>>).

[[metamask_withdraw]]
.Transacción MetaMask para invocar a la función de retiro
image::images/metamask_withdraw.png["Transacción MetaMask para invocar a la función de retiro"]

Esperamos un minuto y luego refrescamos el explorador de bloques de Etherscan para ver la transacción reflejada en el historial de direcciones del contrato +Faucet+ (véase <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan muestra la transacción que invoca a la función "withdraw"
image::images/etherscan_withdrawal_tx.png["Etherscan muestra la transacción que invoca a la función "withdraw""]


Ahora vemos una nueva transacción con la dirección del contrato como destino y un valor de 0 ether. El saldo del contrato ha cambiado y ahora es 0.9 ether porque nos envió 0.1 ether según lo solicitado. Pero rápidamente advertimos que no hay una transacción de salida (con el botoncillo "OUT") en el _historial de la dirección del contrato_.

¿Dónde está el retiro saliente? Esta transacción apareció una nueva pestaña, llamada Transacciones internas, en la página del historial de la dirección del contrato. ((("transacción interna (mensaje)")))Debido a que la transferencia de 0.1 ether se originó en el código del contrato, la misma es una transacción interna (también llamada _mensaje_). Pulsamos clic en esa pestaña para verla (véase la <<etherscan_withdrawal_internal>>).


Esta "transacción interna" fue enviada por el contrato en esta línea de código (originada en la función pass:[<code><span class="keep-together">withdraw</span></code>] de _Faucet.sol_):

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Para recapitular: hemos enviado una transacción desde nuestra cartera MetaMask que contenía instrucciones de datos para invocar a la función +withdraw+ con un argumento +withdraw_amount+ de 0.1 ether. Esa transacción hizo que el contrato se ejecutara dentro de la EVM. Debido a que la EVM ejecutó la función +withdraw+ del contrato +Faucet+, primero llamó a la función +require+ y validó que la cantidad solicitada fuera menor o igual al retiro máximo permitido de 0.1 ether. Luego llamó a la función de transferencia +transfer+ para enviarnos el éter. La ejecución de la función +transfer+ generó una transacción interna que depositó 0.1 ether en la dirección de nuestra cartera, proveniente del saldo del contrato. Ese es la que se muestra en la pestaña de transacciones internas (Internal Transactions) en Etherscan(((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))).(((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan muestra la transacción interna transfiriendo éter fuera del contrato
image::images/etherscan_withdrawal_internal.png["Etherscan muestra la transacción interna transfiriendo éter fuera del contrato"]

[[intro_conclusion]]
=== Conclusiones

En este capítulo, hemos configurado una cartera usando MetaMask y la financiamos usando un grifo en la red de pruebas de Ropsten. Hemos recibido éter en la dirección de Ethereum de nuestra cartera, luego enviamos éter a la dirección de Ethereum del grifo.

A continuación, redactamos un contrato de grifo en Solidity. Usamos el IDE de Remix para compilar el contrato en código binario para la EVM, y luego usamos Remix para formar una transacción y crear el contrato +Faucet+ en la cadena de bloques de Ropsten. Una vez creado, el contrato +Faucet+ poseía una dirección Ethereum, y le enviamos un poco de éter. Finalmente, construimos una transacción para invocar a la función de retiro +withdraw+ y solicitamos con éxito 0.1 ether. El contrato verificó la solicitud y nos envió 0.1 ether mediante una transacción interna.

Puede que no parezca mucho, pero acabamos de interactuar con éxito nada menos que con un software que controla el dinero en una computadora global descentralizada.

Haremos mucha más programación de contratos inteligentes en el <<smart_contracts_chapter>> y aprenderemos sobre las mejores prácticas y consideraciones de seguridad en el <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))